{"version":3,"sources":["../nd-bezier/src/math-functions.ts","../nd-bezier/src/produce-generic-at.ts","../nd-bezier/src/produce-specific-at.ts","../nd-bezier/node_modules/linear-quadratic-cubic-eq-solver/cjs/complex.js","../nd-bezier/node_modules/linear-quadratic-cubic-eq-solver/cjs/index.js","../nd-bezier/src/deterministic-t-search.ts","../nd-bezier/src/static-bezier.ts","node_modules/event-emitter-typesafe/lib/event-emitter.js","node_modules/event-emitter-typesafe/lib/event-emitter-int.js","node_modules/event-emitter-typesafe/lib/make-event-emitter.js","node_modules/event-emitter-typesafe/lib/index.js","src/fit-system.ts","src/interactive.ts"],"names":[],"mappings":";AAca,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,GAAA,QAAA,eAAA,EAdA,QAAA,UAAa,WAChB,MAAA,EAAiB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,IAAK,KAAM,MAAO,OAAQ,QAAS,SAAU,UAAW,WAAY,YAAa,aAAe,cAAgB,eAAiB,iBAUvK,OAJE,SAAU,GACR,OAAA,EAAe,IARJ,GAcb,QAAA,GAAM,WACT,MAAA,EAAsB,GAsBvB,IAAA,IAAI,EAAI,EAAG,GAAK,GAAI,IAAK,CAC1B,EAAQ,GAAK,GACR,IAAA,IAAI,EAAI,EAAG,GAAK,KAAK,KAAK,EAAI,GAAI,IACnC,EAAQ,GAAG,GAAK,QAAA,UAAU,IAAM,QAAA,UAAU,GAAK,QAAA,UAAU,EAAI,IAI9D,OAtBE,SAAG,EAAW,GAKf,OAHA,EAAI,EAAI,IACR,EAAI,EAAI,GAEH,GAAL,EACO,EAEF,GAAL,EACO,EAEJ,EAAQ,GAAG,IAnBP;;ACWnB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,8BAAA,EAzBA,MAAA,EAAA,QAAA,oBAoBM,EAA0B,GAKhC,SAAgB,EAAyB,EAAe,GAGhD,GAAiB,MAAjB,EAFJ,GAAgB,IAGR,GAA4B,MAA5B,EAAO,GAAO,GACd,OAAO,EAAO,GAAO,QAEzB,EAAO,GAAS,GAGhB,IAAA,EAAa,GAIX,MAAA,EAAW,IAAI,MAAM,GAAW,KAAK,IAKtC,IAAA,IAAI,EAAI,EAAG,GAAK,EAAO,IAAK,CACvB,MAAA,EAAiB,IAAM,EAC7B,GAAc,SAAW,EAAiB,MAAQ,EAAA,GAAG,EAAO,GAAM,OAAO,OAAO,GAAO,eAAe,OAAO,EAAQ,GAAM,MAEtH,IAAA,IAAI,EAAI,EAAG,EAAI,EAAW,IAE3B,EAAS,IAAM,EAAiB,aAAe,EAAI,KAAO,EAAI,IAG1D,EAAI,IACJ,EAAS,IAAM,OAIvB,IAAA,EAAiB,GAIhB,IAAA,IAAI,EAAI,EAAG,EAAI,EAAW,IAC3B,GAAkB,OAAS,EAAS,IAAM,GAAK,EAAY,EAAI,KAAO,OAEpE,MAAA,EAAO,8CAAkD,EAAa,aAAe,EAAiB,KACtG,EAAO,IAAI,SAAS,SAAU,IAAK,GAElC,OAAA,EAAO,GAAO,GAAa,CAAC,KAAA,EAAM,KAAA,GA3C7C,QAAA,yBAAA;;AC0DA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,0BAAA,QAAA,eAAA,EAnFA,MAAA,EAAA,QAAA,wBAkCM,EAAc,4BAOpB,SAAgB,EAAU,GAChB,MAAA,EAAgB,GAElB,IAAA,EACG,KAA+B,OAA9B,EAAI,EAAY,KAAK,KACzB,EAAc,EAAc,QAAU,CAClC,OAAQ,EAAE,GAAG,OACb,MAAO,SAAS,EAAE,IAClB,UAAW,SAAS,EAAE,IACtB,MAAO,EAAC,OAGV,MAAA,EAAS,GACX,IAAA,EAAW,EACV,IAAA,IAAI,KAAK,EACK,GAAX,EAAE,QACF,EAAO,EAAO,QAAU,EAAI,MAAM,EAAU,EAAE,QAElD,EAAW,EAAE,MAAQ,EAAE,OAEvB,EAAO,EAAO,QAAU,CACpB,MAAO,EAAE,MACT,UAAW,EAAE,WAIf,MAAA,EAAY,EAAI,OAIf,OAHH,GAAY,IACZ,EAAO,EAAO,QAAU,EAAI,MAAM,EAAU,IAEzC,EAYX,SAAgB,EAA0B,GAChC,MAAA,EAAQ,EAAO,OACf,EAAY,EAAO,GAAG,OAGtB,EAAU,EAAA,yBAAyB,EAAO,GAG5C,IAAA,EAAO,EAAQ,KAIY,MAA3B,EAAQ,kBACR,EAAQ,gBAAkB,EAAU,IAGlC,MAAA,EAAS,EAAQ,gBAGnB,IAAA,EAAc,GACb,IAAA,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAE3B,GAAA,EAAI,GAAK,EACT,GAAe,EAAO,OACnB,CACG,MAAA,EAAO,EAAO,GACpB,GAAe,GAAK,EAAO,EAAK,OAAO,EAAK,WAI7C,OAAA,SAAS,IAAK,GAxEzB,QAAA,UAAA,EA0CA,QAAA,0BAAA;;ACnFA,aACA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,MAAA,EACA,YAAA,EAAA,GACA,KAAA,GAAA,GAAA,EACA,KAAA,GAAA,GAAA,GAMA,EAAA,SAAA,SAAA,EAAA,GACA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAKA,EAAA,IAAA,SAAA,EAAA,GACA,OAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KASA,EAAA,aAAA,SAAA,EAAA,GACA,MAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IACA,OAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,IAKA,EAAA,KAAA,SAAA,EAAA,GACA,MAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAEA,EAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,KAAA,EAAA,GACA,EAAA,IAAA,MAAA,GACA,EAAA,KAAA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,MAAA,GAAA,EAAA,EAAA,KAAA,GAAA,GAAA,EACA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,IAEA,OAAA,GAKA,EAAA,UAAA,SAAA,GACA,MAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAEA,EAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,EACA,EAAA,KAAA,KAAA,EAAA,GAAA,EACA,OAAA,IAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,KAEA,QAAA,QAAA;;AC9DA,aACA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,MAAA,EAAA,QAAA,gBAIA,SAAA,EAAA,EAAA,GACA,OAAA,GAAA,EACA,GAAA,EACA,GAEA,CAAA,GAEA,EAAA,EAAA,GAMA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EACA,OAAA,EAAA,EAAA,GACA,MAAA,EAAA,EAAA,EAEA,EAAA,EAAA,EAAA,EAAA,EADA,EAAA,EAEA,GAAA,EAAA,EAAA,CACA,MAAA,EAAA,KAAA,MAAA,GACA,MAAA,CAAA,IAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,SAAA,EAAA,GAAA,IAEA,CACA,MAAA,EAAA,KAAA,KAAA,GACA,MAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAhBA,QAAA,oBAAA,EAmBA,QAAA,uBAAA,EACA,MAAA,EAAA,IAAA,EAAA,SAAA,GAAA,GAAA,KAAA,KAAA,IACA,EAAA,IAAA,EAAA,SAAA,IAAA,GAAA,KAAA,KAAA,IACA,SAAA,EAAA,EAAA,GACA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,CACA,MAAA,EAAA,KAAA,MAAA,GAAA,EACA,EAAA,EAAA,EAIA,OAAA,EAAA,QAAA,UAAA,IAAA,EAAA,QAAA,EAAA,IAGA,OAAA,IAAA,EAAA,QAAA,KAAA,MAAA,EAAA,KAAA,KAAA,IAAA,GAAA,GAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GAEA,MAAA,EAAA,EAAA,QAAA,aAAA,EAAA,GAEA,OADA,IAAA,EAAA,UAAA,EAAA,GAAA,EAAA,GAAA,IAAA,EAAA,KAAA,EAAA,GAAA,EAAA,KAAA,EAAA,IAMA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EACA,OAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,CACA,MAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,CAAA,GACA,EAAA,EAAA,OAOA,OANA,EAAA,IACA,EAAA,GAAA,EAAA,GACA,EAAA,IACA,EAAA,GAAA,EAAA,KAGA,EAEA,MAAA,EAAA,EAAA,EACA,EAAA,EAAA,EASA,EAAA,EAAA,EARA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EACA,GAAA,EAAA,EAAA,GAOA,EAAA,EAAA,QAAA,SAAA,EAAA,GACA,EAAA,EAAA,QAAA,SAAA,EAAA,GAIA,MAAA,CAHA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAGA,QAAA,mBAAA;;ACtBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,gCAAA,EAvEA,MAAA,EAAA,QAAA,oCAaM,EAAU,CAAC,EAAY,EAAgB,KACnC,MAAA,EAAM,EAAS,EACjB,GAAA,EAAK,EACL,OAAO,EAAK,EAEV,MAAA,EAAM,EAAS,EACjB,OAAA,EAAK,EACE,EAAK,EAET,GAOL,EAAkB,IACd,MAAA,EAAc,GAEf,IAAA,MAAM,KAAK,EACI,iBAAL,EACP,EAAE,KAAK,GACwB,GAA1B,EAAQ,EAAE,GAAI,EAAG,OACtB,EAAE,KAAK,EAAE,IAIV,OAAA,GAKL,EAA6B,CAC/B,CAAC,EAAG,KACM,MAAA,EAAI,EAAE,GAAK,EAAE,GACb,EAAI,EAAE,GAAK,EAEV,OAAA,EAAe,EAAA,oBAAoB,EAAG,KAGjD,CAAC,EAAG,KACM,MAAA,EAAI,EAAE,GAAK,EAAI,EAAE,GAAK,EAAE,GACxB,GAAK,EAAI,EAAE,GAAK,EAAI,EAAE,GACtB,EAAI,EAAE,GAAK,EAEV,OAAA,EAAe,EAAA,uBAAuB,EAAG,EAAG,KAGvD,CAAC,EAAG,KACM,MAAA,GAAK,EAAE,GAAK,EAAI,EAAE,GAAK,EAAI,EAAE,GAAK,EAAE,GACpC,EAAI,EAAI,EAAE,GAAK,EAAI,EAAE,GAAK,EAAI,EAAE,GAChC,GAAK,EAAI,EAAE,GAAK,EAAI,EAAE,GACtB,EAAI,EAAE,GAAK,EAEV,OAAA,EAAe,EAAA,mBAAmB,EAAG,EAAG,EAAG,MAI1D,SAAgB,EAA2B,GACjC,MAAA,EAAQ,EAAO,OACf,EAAY,EAAO,GAAG,OAExB,GAAS,MAAT,GAAiB,EAAQ,GAAK,EAAQ,EACtC,OAAO,KAEL,MAAA,EAA+B,GAEhC,IAAA,IAAI,EAAI,EAAG,EAAI,EAAW,IAAK,CAC1B,MAAA,EAAe,GAEhB,IAAA,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAC/B,EAAG,KAAK,EAAO,GAAG,IAEtB,EAAiB,KAAK,GAGpB,MAAA,EAAO,EAAiB,EAAQ,GAE/B,MAAA,CAAC,EAAW,IACR,EAAK,EAAiB,GAAI,GArBzC,QAAA,2BAAA;;AClDA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,kBAAA,EArBA,MAAA,EAAA,QAAA,yBACA,EAAA,QAAA,4BAEM,EAA4B,IACxB,MAAA,EAAK,EAAA,0BAA0B,GAEjC,GAAM,MAAN,EACA,MAAM,IAAI,MAAM,iDAAmD,KAAK,UAAU,IAE/E,OAAA,GAGL,EAAsC,IAClC,MAAA,EAAU,EAAA,2BAA2B,GAEvC,GAAW,MAAX,EACA,MAAM,IAAI,MAAM,sDAAwD,KAAK,UAAU,IAEpF,OAAA,GAGX,MAAa,EAET,YAAY,GACH,KAAA,GAAK,EAAyB,GAC9B,KAAA,QAAU,EAAmC,GAGtD,GAAG,GACO,MAAA,IAAI,MAGd,QAAQ,EAAe,GACb,MAAA,IAAI,OAZlB,QAAA,aAAA;;ACrBA,aACA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,QAAA,kBAAA,EACA,MAAA,EAAA,OAAA,aACA,EAAA,IACA,MAAA,EAAA,OAAA,yBAAA,EAAA,GACA,QAAA,IAAA,EAAA,CACA,MAAA,EAAA,OAAA,OAAA,MAOA,OANA,OAAA,eAAA,EAAA,EAAA,CACA,MAAA,EACA,cAAA,EACA,YAAA,EACA,UAAA,IAEA,EAGA,OAAA,EAAA,OAEA,EAAA,CAAA,EAAA,KACA,MAAA,EAAA,EAAA,GACA,OAAA,KAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAEA,MAAA,EAEA,iBAAA,EAAA,GACA,EAAA,KAAA,GACA,KAAA,GAGA,GAAA,EAAA,IACA,YAAA,EAAA,IACA,UAAA,EAAA,IACA,KAAA,EAAA,GACA,MAAA,EAAA,IACA,KAAA,oBAAA,EAAA,GACA,EAAA,IAEA,KAAA,iBAAA,EAAA,GAEA,QAAA,GACA,OAAA,IAAA,QAAA,GAAA,KAAA,KAAA,EAAA,IAEA,KAAA,EAAA,GACA,MAAA,EAAA,EAAA,KAAA,GAEA,IAAA,MAAA,KAAA,EAAA,QACA,EAAA,KAAA,KAAA,GAGA,SAAA,EAAA,IACA,KAAA,EAAA,IACA,QAAA,EAAA,IACA,oBAAA,EAAA,GACA,MAAA,EAAA,EAAA,KAAA,GACA,EAAA,EAAA,QAAA,GACA,OAAA,GAAA,IAEA,EAAA,OAAA,EAAA,IACA,GAGA,IAAA,EAAA,GAAA,OAAA,EACA,eAAA,EAAA,GAAA,OAAA,EACA,YAAA,EAAA,GAAA,OAAA,GAEA,QAAA,aAAA,EAEA,EAAA,UAAA,GAAA,EAAA,UAAA,iBACA,EAAA,UAAA,YAAA,EAAA,UAAA,iBACA,EAAA,UAAA,UAAA,EAAA,UAAA,iBACA,EAAA,UAAA,SAAA,EAAA,UAAA,KACA,EAAA,UAAA,KAAA,EAAA,UAAA,SACA,EAAA,UAAA,QAAA,EAAA,UAAA,SACA,EAAA,UAAA,IAAA,EAAA,UAAA,oBACA,EAAA,UAAA,eAAA,EAAA,UAAA,oBACA,EAAA,UAAA,YAAA,EAAA,UAAA;;AC5EA,aACA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA;;ACDA,aACA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,QAAA,sBAAA,EACA,MAAA,EAAA,QAAA,mBACA,EAAA,OAAA,0BAAA,EAAA,aAAA,WAYA,SAAA,EAAA,GAEA,MAAA,EAAA,EAAA,UACA,EAAA,OAAA,0BAAA,GACA,IAAA,MAAA,KAAA,EACA,GAAA,KAAA,EACA,MAAA,IAAA,MAAA,OAAA,GAAA,uDACA,OAAA,iBAAA,EAAA,UAlBA,EAAA,YAoBA,QAAA,iBAAA;;ACzBA,aACA,IAAA,EAAA,MAAA,KAAA,kBAAA,OAAA,OAAA,SAAA,EAAA,EAAA,EAAA,QACA,IAAA,IAAA,EAAA,GACA,OAAA,eAAA,EAAA,EAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,OACA,SAAA,EAAA,EAAA,EAAA,QACA,IAAA,IAAA,EAAA,GACA,EAAA,GAAA,EAAA,KAEA,EAAA,MAAA,KAAA,cAAA,SAAA,EAAA,GACA,IAAA,IAAA,KAAA,EAAA,YAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAEA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IACA,EAAA,QAAA,mBAAA,SACA,EAAA,QAAA,uBAAA,SACA,EAAA,QAAA,wBAAA;;ACdA,aAkMA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA9LA,QAAA,qBAAA,QAAA,eAAA,QAAA,eAAA,EASA,MAAM,EAAW,CAAC,EAAO,IAAU,KAAK,MAAM,EAAE,GAAK,EAAE,KAAO,GAAK,EAAE,GAAK,EAAE,KAAO,GAiBnF,SAAgB,EAA8B,EAAO,EAAc,EAAO,EAAc,GAE9E,MAAA,EAAQ,EAAS,EAAU,GAAY,EAAS,EAAG,GAGnD,EAAU,EAEX,EAAE,GAAK,EAAE,IAAM,GAEf,EAAE,GAAK,EAAE,IAAM,GAGd,GAAQ,EAAS,GAAK,EAAS,IAAM,EAAS,GAAK,EAAS,IAAM,EAAI,GAAK,EAAI,IACjF,EAAI,IAAM,EAAI,GAAK,EAAI,GAAK,EAAI,GAAK,EAAI,IAEvC,EAAO,KAAK,IAAI,KAAK,KAAK,IAEzB,OAAA,EAAM,IAAI,EAAE,EAAG,MAEZ,MAAA,EAAS,CAAC,EAAI,EAAE,GAAI,EAAI,EAAE,IAG1B,EAAe,CAChB,EAAO,EAAQ,EAAG,GAAK,EAAO,EAAQ,EAAG,GACzC,EAAO,EAAQ,EAAG,GAAK,EAAO,EAAQ,EAAG,IAIvC,MAAA,CACH,EAAE,GAAK,EAAa,GACpB,EAAE,GAAK,EAAa,MAKhC,SAAgB,EAAmC,EAAQ,EAAc,EAAQ,EAAc,GACrF,MAAA,EAAI,EAAG,GACP,EAAI,EAAG,GAEP,EAAI,EAAG,GACP,EAAI,EAAG,GAEP,EAAI,EAAS,GACb,EAAI,EAAS,GAEb,EAAI,EAAS,GACb,EAAI,EAAS,GAEb,GAAK,EAAI,EAAI,EAAI,GAAK,GAAK,GAAK,EAAI,EAAI,GACxC,GAAK,EAAI,EAAI,EAAI,GAAK,GAAK,GAAK,EAAI,EAAI,GAExC,GAAK,EAAI,EAAI,GAAK,EAClB,GAAK,EAAI,EAAI,GAAK,EAEjB,OAAA,EAAM,IAAI,EAAE,EAAG,KAIX,CACH,EAAI,EAAI,EAAI,EACZ,EAAI,EAAI,EAAI,IA5DxB,QAAA,UAAA,EAmCA,QAAA,eAAA,EA8BA,MAAM,EAAY,CAAC,EAAO,EAAY,KAC5B,MAAA,EAAS,KAAK,KAAK,EAAE,GAAK,EAAE,GAAK,EAAE,GAAK,EAAE,IAEzC,MAAA,CACH,EAAY,EAAE,GAAK,EACnB,EAAY,EAAE,GAAK,IAIrB,EAAc,GACT,CACH,EAAE,IACD,EAAE,IAIL,EAAe,GACV,EACF,EAAE,GACH,EAAE,IAIJ,EAAY,CAAC,EAAU,IAClB,CACH,EAAG,GAAK,EAAK,GACb,EAAG,GAAK,EAAK,IAIf,EAAM,CAAC,EAAO,IACT,CACH,EAAE,GAAK,EAAE,GACT,EAAE,GAAK,EAAE,IAIX,EAAS,CAAC,EAAW,EAAW,EAAQ,OAAS,KAAK,IAAI,EAAI,GAAK,EAEnE,EAAgB,CAAC,EAAO,KACpB,MAAA,EAAQ,EAAU,EAAG,GACrB,EAAQ,EAAU,EAAG,GAGnB,OAAA,EAAO,EAAM,GAAI,EAAM,KAAO,EAAO,EAAM,GAAI,EAAM,KACxD,EAAO,EAAM,IAAK,EAAM,KAAO,EAAO,EAAM,IAAK,EAAM,KAG1D,EAAW,CAAC,EAAO,IACd,CACH,EAAE,GAAK,EACP,EAAE,GAAK,GAKT,EAAe,CAAC,EAAW,EAAgB,EAAW,KACpD,GAAA,EAAc,EAAY,GAC1B,MAAO,wBAKP,GAAiB,GAAjB,EAAW,GAAS,CACd,MAAA,EAAW,EACjB,EAAQ,EACR,EAAQ,EAEF,MAAA,EAAgB,EACtB,EAAa,EACb,EAAa,EAGX,MAAA,EAAQ,EAAM,GACd,EAAQ,EAAM,GAEd,EAAQ,EAAM,GAAK,EAAW,GAC9B,EAAQ,EAAM,GAAK,EAAW,GAE9B,EAAI,EAAQ,EACZ,EAAI,EAAQ,EACZ,EAAI,EAAQ,EAAQ,EAAQ,EAE5B,EAAQ,EAAM,GACd,EAAQ,EAAM,GAEd,EAAQ,EAAM,GAAK,EAAW,GAC9B,EAAQ,EAAM,GAAK,EAAW,GAE9B,EAAI,EAAQ,EAIZ,GAAK,EAAI,GAFL,EAAQ,EAAQ,EAAQ,GAEX,IAAM,GAHnB,EAAQ,GAGmB,EAAI,GAGlC,MAAA,GAFK,EAAI,EAAI,GAAK,EAEd,IAGf,SAAgB,EAAyC,EAAU,EAA6B,GACtF,MAAA,EAAsB,QAAb,EAAsB,EAAa,EAC5C,EAA2B,QAAb,EAAsB,EAAc,EAElD,EAAa,GAEnB,CACU,MAAA,EAAW,EAAU,EAAE,GAAI,EAAE,IAE7B,EAAS,EADM,EAAU,EAAU,IAEzC,EAAI,KAAK,EAAI,EAAE,GAAI,IAGlB,IAAA,IAAI,EAAI,EAAG,EAAI,EAAE,OAAS,EAAG,IAAK,CAC7B,MAAA,EAAW,EAAU,EAAE,EAAI,GAAI,EAAE,IACjC,EAAe,EAAI,EAAE,EAAI,GAAI,EAAU,EAAO,GAAW,IAEzD,EAAW,EAAU,EAAE,EAAI,GAAI,EAAE,IACjC,EAAe,EAAI,EAAE,EAAI,GAAI,EAAU,EAAY,GAAW,IAE9D,EAAW,EAAa,EAAc,EAAU,EAAc,GAC7C,iBAAZ,EAGP,EAAI,KAAK,EAAI,EAAE,GAAI,EAAU,EAAO,GAAW,KAE/C,EAAI,KAAK,GAKjB,CACU,MAAA,EAAS,EAAU,EAAE,EAAE,OAAS,GAAI,EAAE,EAAE,OAAS,IAEjD,EAAS,EADM,EAAU,EAAQ,IAEvC,EAAI,KAAK,EAAI,EAAE,EAAE,OAAS,GAAI,IAG3B,OAAA,EAtCX,QAAA,qBAAA;;AC2WA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,WAAA,EA7iBA,MAAA,EAAA,QAAA,qCAEA,EAAA,QAAA,0BACA,EAAA,QAAA,gBAEM,EAAS,IACT,EAAQ,KACR,EAAS,IAYf,SAAS,EAAO,EAAmB,GAGzB,MAAA,EAAY,EAAI,EAChB,GAAM,EAAI,EAAY,EACtB,EAAK,EAAI,EAAI,EAAI,GAAK,EAAI,EAC1B,EAAK,EAAI,EAAI,EAAI,EAAI,EACrB,EAAK,EAAI,EAAI,EACZ,MAAA,CACH,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,GAC3E,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,GAAK,EAAK,EAAO,GAAG,IAInF,MAAM,EAAc,GAEpB,SAAS,EAAW,EAA+B,EAAmB,EAAS,GAC3E,EAAI,YAEC,IAAA,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CAC9B,MAAA,EAAI,EAAO,GACjB,EAAI,OAAO,EAAE,GAAI,EAAE,IACnB,EAAI,IAAI,EAAE,GAAI,EAAE,GAAI,EAAQ,EAAG,KAGnC,EAAI,OACJ,EAAI,YAGR,SAAS,EAAa,EAA+B,GAC7C,GAAiB,GAAjB,EAAO,OACP,OAEJ,EAAI,YAEE,MAAA,EAAa,EAAO,GAC1B,EAAI,OAAO,EAAW,GAAI,EAAW,IAChC,IAAA,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CAC9B,MAAA,EAAQ,EAAO,GACrB,EAAI,OAAO,EAAM,GAAI,EAAM,IAG/B,EAAI,SACJ,EAAI,YAGR,SAAS,EAAgC,EAAmB,EAAW,GAC7D,MAAA,EAAM,EAAO,EAAQ,GACrB,EAAY,KAAK,KAAK,EAAI,GAAK,EAAI,GAAK,EAAI,GAAK,EAAI,IACrD,EAAU,CAAC,EAAW,EAAI,GAAK,EAAW,EAAW,EAAI,GAAK,GAG9D,MAAA,EADO,IAAI,EAAA,aAAa,GACT,GAAG,GAEjB,MAAA,CAEF,CAAA,EAAM,GAAK,EAAQ,GAAI,EAAM,IAAM,EAAQ,IAG3C,CAAA,EAAM,GAAI,EAAM,IAGhB,CAAA,EAAM,IAAM,EAAQ,GAAI,EAAM,GAAK,EAAQ,KAIpD,SAAS,EAAiB,EAA+B,EAAiB,EAAgB,EAAkB,GACpG,GAAU,GAAV,GAAmC,GAApB,EAAU,OACzB,OAEE,MAAA,EAAuC,GACvC,EAAsC,GAEvC,IAAA,IAAI,EAAI,EAAG,GAAK,EAAQ,IAAK,CACxB,MAAA,EAAI,EAAI,GACP,EAAM,EAAQ,GAAS,EAAgC,EAAW,EAAG,GAE5E,EAAe,KAAK,CAChB,EACA,IAGJ,EAAc,KAAK,CACf,EACA,IAIF,MAAA,EAAsB,EAAI,YAsB5B,GApBJ,EAAI,YAAc,OAClB,EAAa,EAAK,EAAe,IAAI,GAAK,EAAE,KAS5C,EAAI,YAAc,OAClB,EAAa,EAAK,EAAc,IAAI,GAAK,EAAE,KASvC,EAAc,CACR,MAAA,EAAgB,EAAI,UAC1B,EAAI,YAAc,OAClB,EAAI,UAAY,EAAgB,EAChC,EAAI,YACC,IAAA,MAAM,IAAO,CAAC,EAAe,GACzB,IAAA,MAAO,EAAO,KAAQ,EACvB,EAAI,OAAO,EAAM,GAAI,EAAM,IAC3B,EAAI,OAAO,EAAI,GAAI,EAAI,IAI/B,EAAI,SACJ,EAAI,YACJ,EAAI,UAAY,EAGpB,EAAI,YAAc,EAGtB,SAAS,EAAW,EAAsB,EAA+B,EAAe,EAAS,GACzF,GAAA,EAAU,OAAS,GAAK,EAAU,OAAS,EAC3C,OAEE,MAAA,EAAS,IAAI,EAAA,aAAa,GAC1B,EAAoB,GAErB,IAAA,IAAI,EAAI,EAAG,GAAK,EAAO,IACxB,EAAO,KAAK,EAAO,GAAG,EAAI,IAG9B,EAAa,EAAK,GAGtB,MAAM,EAAU,CACZ,OAAQ,CAAC,4BAA4B,GACrC,eAAgB,CAAC,sCAAsC,IAG3D,SAAS,EAAU,GACR,OAAA,EAAQ,GAAK,GAGxB,MAAM,EAAM,IAAI,KAAK,aAAa,QAAS,CACvC,sBAAuB,EACvB,sBAAuB,EACvB,aAAa,IACd,OAEG,EAAS,GAAe,EAAI,GAAI,SAAS,EAAG,KAC5C,EAAU,GAAkB,IAAM,EAAI,IAAI,GAAO,KAAK,MAAQ,IAEpE,IAAI,EACA,EAIJ,SAAgB,EAAM,EAAW,EAAc,EAAsB,QAAS,EAAuB,QAAS,EAAiB,GACvH,IAAC,IAAc,EACf,OAEE,MAAA,EAAS,EAAO,GACtB,EAAU,WAAa,EAAO,KAAO,EAAS,KAExC,MAAA,EAAe,EAAQ,UAE7B,EAAQ,UAAY,EACpB,EAAW,EAAS,CAAC,IAErB,EAAQ,UAAY,EACpB,EAAQ,UAAY,OACpB,EAAQ,aAAe,SACjB,MAAA,EAAM,EAAU,kBAAoB,EAAO,IAAM,EAAS,EAChE,EAAQ,SAAS,EAAK,EAAM,GAAK,EAAQ,EAAM,GAAK,GAEpD,EAAQ,UAAY,EAIxB,SAAS,IACC,MAAA,EAAc,SAAS,eAAe,gBACtC,EAAS,SAAS,eAAe,UACjC,EAAkB,SAAS,eAAe,WAEhD,EAAY,EAEZ,EAAO,aAAa,SAAU,EAAS,IACvC,EAAO,aAAa,QAAS,EAAQ,IAGhC,IAAA,MAAM,KAAO,OAAO,KAAK,GAAU,CAC9B,MAAC,EAAa,GAAiB,EAAgB,GAC/C,EAAW,SAAS,cAAc,SAClC,EAAK,UAAY,EACvB,EAAS,GAAK,EACd,EAAS,KAAO,WAChB,EAAS,QAAU,EAEb,MAAA,EAAQ,SAAS,cAAc,SACrC,EAAM,UAAY,EAClB,EAAM,QAAU,EAEV,MAAA,EAAU,SAAS,cAAc,OACvC,EAAQ,UAAY,iBAEpB,EAAQ,OAAO,EAAU,GAEzB,EAAgB,OAAO,GAEvB,EAAS,iBAAiB,SAAU,IAAO,EAAgB,GAAK,GAAK,EAAS,SAG5E,MAAA,EAAoB,MAClB,IAAA,OAAgC,EAE9B,MAAA,EAAa,KACf,sBAAsB,GACtB,OAAQ,GAIL,OAFP,IAEO,WACC,OAAA,IAGG,EAAQ,EAAO,2BAbJ,GAiBjB,SAAA,EAAY,GACX,MAAA,EAAO,IAEN,MAAA,CACH,EAAG,QAAU,EAAK,KAClB,EAAG,QAAU,EAAK,KAIpB,MAAA,EAAM,EAAO,WAAW,MAE1B,IAAC,EACD,MAAM,IAAI,MAAM,wBAEpB,EAAU,EAEV,EAAI,UAAY,EAChB,EAAI,YAAc,OAEZ,MAAA,EAAa,IAAM,IAAI,QAAQ,GAAO,sBAAsB,IAgB5D,EAAc,IAAI,EAAA,aAExB,SAAS,iBAAiB,YAAa,GACnC,EAAY,KAAK,YAAa,CAAC,KAAM,YAAa,SAAU,EAAI,SAAU,EAAY,MAE1F,SAAS,iBAAiB,YAAa,GACnC,EAAY,KAAK,YAAa,CAAC,KAAM,YAAa,SAAU,EAAI,SAAU,EAAY,MAE1F,SAAS,iBAAiB,UAAW,GACjC,EAAY,KAAK,UAAW,CAAC,KAAM,UAAW,SAAU,EAAI,SAAU,EAAY,MAElF,IAAA,OAAwC,EACxC,GAAmB,EAEvB,EAAY,iBAAiB,YAAa,IACtC,EAAmB,EAAG,SACtB,GAAmB,IAGvB,EAAY,iBAAiB,UAAW,IACpC,OAAmB,EACf,EACA,EAAY,KAAK,UAAW,CACxB,KAAM,UACN,SAAU,EAAG,SACb,SAAU,EAAG,WAGjB,EAAY,KAAK,QAAS,CACtB,KAAM,QACN,SAAU,EAAG,SACb,SAAU,EAAG,aAIrB,IAAA,OAAgC,EAEpC,EAAY,iBAAiB,YAAa,IAElC,GADJ,EAAgB,EAAG,SACf,EAAG,SAAS,QAAU,GAAK,EAAkB,CACvC,MAAA,EAAO,EACb,EAAmB,EAAG,SAEjB,EAQD,EAAY,KAAK,OAAQ,CACrB,KAAM,OACN,SAAU,EAAG,SACb,SAAU,EAAG,SACb,SAAU,KAXd,GAAmB,EACnB,EAAY,KAAK,YAAa,CAC1B,KAAM,YACN,SAAU,EAAG,SACb,SAAU,EAAG,eAezB,IAAA,EAAiB,GAErB,EAAY,iBAAiB,QAAS,GAAM,EAAe,KAAK,IAChE,EAAY,iBAAiB,YAAa,GAAM,EAAe,KAAK,IACpE,EAAY,iBAAiB,OAAQ,GAAM,EAAe,KAAK,IAC/D,EAAY,iBAAiB,UAAW,GAAM,EAAe,KAAK,IAClE,EAAY,iBAAiB,YAAa,GAAM,EAAe,KAAK,IACpE,EAAY,iBAAiB,UAAW,GAAM,EAAe,KAAK,IAClE,EAAY,iBAAiB,YAAa,GAAM,EAAe,KAAK,IAE9D,MAIA,GAAO,EAFQ,KAEiB,EAChC,GAAQ,EAJM,KAIiB,EAC/B,EAAS,EAAS,EAClB,EAAQ,EAAQ,EAElB,IAqBA,EArBA,EAAY,CACZ,CAAC,EAAO,GAAc,EAVT,KAWb,CAAC,EAAQ,GAAc,EAXV,KAYb,CAAC,EAAQ,GAAc,EAZV,KAab,CAAC,EAAO,GAAc,EAbT,MAgBR,SAAA,EAAY,EAAmB,EAAc,GAE7C,IAAA,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CAC9B,MAAA,EAAQ,EAAO,GACf,EAAS,EAAM,GAAK,EAAI,GACxB,EAAS,EAAM,GAAK,EAAI,GAEzB,GAAA,EAAS,EAAS,EAAS,GAAW,EAAQ,EAC/C,OAAO,GAQV,SAAA,EAAc,GACZ,OAAA,OAAO,aAAa,IAAI,WAAW,GAAK,GAGnD,EAAI,KAAO,eAEL,MAAA,EAAQ,KAAK,MAClB,WACU,OAAM,CACH,MAAA,EAAQ,KAAK,MAAQ,EAEb,KAAK,IAAI,EAAQ,IAAQ,KAAK,IAC5C,EAAI,UAAU,EAAG,EAAG,EAAO,GAC3B,EAAU,UAAY,GAWhB,MAAA,EAA8C,GAChD,IAAA,OAA+C,EAE9C,IAAA,MAAM,KAAS,EACE,aAAd,EAAM,KACN,EAAc,CACV,OAAO,EACP,YAAY,EACZ,OAAO,EAEP,cAAe,EAAM,SACrB,YAAa,EAAM,UAEF,QAAd,EAAM,KACT,GACA,EAAY,YAAa,EACzB,EAAY,YAAc,EAAM,UAGhC,EAAc,CACV,OAAO,EACP,YAAY,EACZ,OAAO,EAEP,cAAe,EAAM,SACrB,YAAa,EAAM,UAGN,WAAd,EAAM,OACT,GACA,EAAY,OAAQ,EACpB,EAAY,YAAc,EAAM,SAChC,EAAqB,KAAK,GAC1B,OAAc,GAGd,EAAqB,KAAK,CACtB,OAAO,EACP,YAAY,EACZ,OAAO,EAEP,cAAe,EAAM,SACrB,YAAa,EAAM,YAM/B,GACA,EAAqB,KAAK,GAEzB,IAAA,MAAM,KAAe,EAIlB,GAHoB,MAApB,IACA,EAAmB,EAAY,EAAW,EAAY,cAAe,IAEjD,MAApB,EAA+B,CACzB,MAAA,EAAS,EAAY,YAAY,GAAK,EAAY,cAAc,GAChE,EAAS,EAAY,YAAY,GAAK,EAAY,cAAc,GAEhE,EAAQ,EAAU,GAGxB,EAAM,IAAM,EACZ,EAAM,IAAM,EAER,EAAY,QACZ,OAAmB,GAIP,MAApB,EACA,EAAO,MAAM,OAAS,WACf,IACmD,MAAtD,EAAY,EAAW,EAAe,GACtC,EAAO,MAAM,OAAS,OAEtB,EAAO,MAAM,OAAS,WAGzB,IAAA,MAAM,KAAS,EACZ,EAAM,KAQd,EAAiB,GAEX,MAAA,EAAgB,GAElB,GAAoB,GAApB,EAAU,OAAa,CAEvB,EAAI,UAAY,QAChB,EAAI,UAAY,EAChB,EAAI,YAAc,OAElB,EAAW,EAAW,EAAK,GAE3B,EAAiB,EAAK,EAAW,EA5J5B,IA4JqD,EAAU,WAEpE,EAAI,UAAY,QAChB,EAAI,YAAc,OAEb,IAAA,MAAM,IAAQ,CAAC,OAAQ,SAAU,CAC5B,MAAA,EAAU,EAAA,qBAAqB,EAAW,EAlK/C,KAmKD,EAAI,UAAY,EAChB,EAAI,YAAc,OAElB,EAAW,EAAS,EAAK,EAAe,GACxC,EAAI,YAAY,CAAC,EAAG,IACpB,EAAa,EAAK,GAClB,EAAI,YAAY,IAEX,IAAA,IAAI,EAAI,EAAG,EAAI,EAAQ,OAAQ,IAChC,EAAM,EAAQ,GAAI,EAAc,GAAK,YAAc,GAG3D,EAAI,UAAY,QAChB,EAAI,YAAc,OAElB,EAAa,EAAK,GAEb,IAAA,IAAI,EAAI,EAAG,EAAI,EAAU,OAAQ,IAClC,EAAM,EAAU,GAAI,EAAc,GAAI,GAAoB,EAAI,MAAQ,gBAGxE,MAjJb,GA3NL,QAAA,MAAA,EAmXA,SAAS,iBAAiB,mBAAoB","file":"interactive.e710c6d7.js","sourceRoot":"..","sourcesContent":["export const factorial = (function () {\r\n    const factorialCache = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000];\r\n\r\n    /**\r\n     * Calculates n!\r\n     * @param n\r\n     */\r\n    function factorial(n: number) {\r\n        return factorialCache[n];\r\n    }\r\n\r\n    return factorial;\r\n})();\r\n\r\nexport const bc = (function () {\r\n    const bcCache: number[][] = [];\r\n\r\n    /**\r\n     * Calculates the binomial coefficient for n over k\r\n     * @param n\r\n     * @param k\r\n     */\r\n    function bc(n: number, k: number): number {\r\n\r\n        if (k > n / 2)\r\n            k = n - k;\r\n\r\n        if (k == 0)\r\n            return 1;\r\n\r\n        if (k == 1)\r\n            return n;\r\n\r\n        return bcCache[n][k];\r\n    }\r\n\r\n    // building up cache\r\n    for (let n = 0; n <= 15; n++) {\r\n        bcCache[n] = [];\r\n        for (let k = 0; k <= Math.ceil(n / 2); k++) {\r\n            bcCache[n][k] = factorial(n) / (factorial(k) * factorial(n - k));\r\n        }\r\n    }\r\n\r\n    return bc;\r\n})();\r\n\r\n","import {bc} from \"./math-functions\";\r\n\r\nexport interface AtFunction {\r\n    (points: number[][], t: number): number[];\r\n}\r\n\r\ninterface FCacheEntry {\r\n    body: string,\r\n    func: AtFunction,\r\n    // an array of the textual point positions and the surrounding string, used for replacement in produceSpecificAtFunction\r\n    pointsPositions?: ({\r\n        point: number,\r\n        // the number d of point[p][d]\r\n        dimension: number\r\n    } | string)[]\r\n}\r\n\r\n/**\r\n * caching the created generic functions and its body and its pointsPositions\r\n */\r\nconst fCache: FCacheEntry[][] = [];\r\n\r\n/**\r\n * This function generates an general at function which is usable for this specific combination of grade and dimension.\r\n */\r\nexport function produceGenericAtFunction(grade: number, dimension: number): FCacheEntry {\r\n    grade = grade - 1;\r\n\r\n    if (fCache[grade] != undefined) {\r\n        if (fCache[grade][dimension] != undefined)\r\n            return fCache[grade][dimension];\r\n    } else\r\n        fCache[grade] = [];\r\n\r\n    // collects all multiplier\r\n    let multiplier = \"\";\r\n\r\n    // point sum is an array of strings which collect the sum of the point dimension\r\n    // pointSum[0]: \"m0 * 1 + m1 * 2 + ...\" etc.\r\n    const pointSum = new Array(dimension).fill(\"\");\r\n\r\n    // for each grade one multiplier is created\r\n    // const m0 = 1 * t * t * t * oneMinusT; etc.\r\n    // and each buffer will be extended for the current multiplier\r\n    for (let g = 0; g <= grade; g++) {\r\n        const multiplierName = \"m\" + g;\r\n        multiplier += \"const \" + multiplierName + \" = \" + bc(grade, g) + (\" * t\".repeat(g)) + (\" * oneMinusT\".repeat(grade - g)) + \";\\n\";\r\n\r\n        for (let d = 0; d < dimension; d++) {\r\n            // pointSum[d] += multiplierName + \" * \" + point[d]; // this would make it a specific function\r\n            pointSum[d] += multiplierName + \" * points[\" + g + \"][\" + d + \"]\";\r\n\r\n\r\n            if (g < grade)\r\n                pointSum[d] += \" + \";\r\n        }\r\n    }\r\n\r\n    let pointSumConcat = \"\";\r\n    \r\n    // each buffer will be terminated by a semicolon\r\n    // concatenating the pointSum to one string\r\n    for (let i = 0; i < dimension; i++)\r\n        pointSumConcat += \"    \" + pointSum[i] + (i == dimension - 1 ? \"\\n\" : \",\\n\");\r\n\r\n    const body = \"\\\"use strict\\\";\\n\\nconst oneMinusT = 1 - t;\\n\" + multiplier + \"return [\\n\" + pointSumConcat + \"];\";\r\n    const func = new Function('points', 't', body) as AtFunction;\r\n\r\n    return fCache[grade][dimension] = {body, func};\r\n}","import {produceGenericAtFunction} from \"./produce-generic-at\";\r\n\r\ninterface SpecificAtFunction {\r\n    (t: number): number[]\r\n}\r\n\r\n/*\r\nfrom: \r\n\r\n\"use strict\";\r\nconst oneMinusT = 1 - t;\r\nconst rePoint = [NaN, NaN];\r\nconst m0 = 1 * oneMinusT * oneMinusT * oneMinusT;\r\nconst m1 = 3 * t * oneMinusT * oneMinusT;\r\nconst m2 = 3 * t * t * oneMinusT;\r\nconst m3 = 1 * t * t * t;\r\nrePoint[0] = m0 * points[0][0] + m1 * points[1][0] + m2 * points[2][0] + m3 * points[3][0];\r\nrePoint[1] = m0 * points[0][1] + m1 * points[1][1] + m2 * points[2][1] + m3 * points[3][1];\r\nreturn rePoint;\r\n\r\nto:\r\n\r\n\"use strict\";\r\nconst oneMinusT = 1 - t;\r\nconst rePoint = [NaN, NaN];\r\nconst m0 = 1 * oneMinusT * oneMinusT * oneMinusT;\r\nconst m1 = 3 * t * oneMinusT * oneMinusT;\r\nconst m2 = 3 * t * t * oneMinusT;\r\nconst m3 = 1 * t * t * t;\r\nrePoint[0] = m0 * 0 + m1 * 1 + m2 * 0 + m3 * 1;\r\nrePoint[1] = m0 * 0 + m1 * 0 + m2 * 1 + m3 * 1;\r\nreturn rePoint;\r\n*/\r\n\r\nconst pointsRegEx = /points\\[(\\d+)\\]\\[(\\d+)\\]/g;\r\n\r\n/**\r\n * transforms the given string into an array of strings and objects\r\n *\r\n * the string will be concatenated with the objects string representation\r\n */\r\nexport function getPlaces(str: string) {\r\n    const searchResults = [];\r\n\r\n    let f;\r\n    while ((f = pointsRegEx.exec(str)) != null)\r\n        searchResults[searchResults.length] = {\r\n            length: f[0].length,\r\n            point: parseInt(f[1]),\r\n            dimension: parseInt(f[2]),\r\n            start: f['index']\r\n        };\r\n\r\n    const result = [];\r\n    let prevStop = 0;\r\n    for (let f of searchResults) {\r\n        if (f.start != 0) {\r\n            result[result.length] = str.slice(prevStop, f.start);\r\n        }\r\n        prevStop = f.start + f.length;\r\n\r\n        result[result.length] = {\r\n            point: f.point,\r\n            dimension: f.dimension\r\n        }\r\n    }\r\n\r\n    const strLength = str.length;\r\n    if (prevStop != strLength)\r\n        result[result.length] = str.slice(prevStop, strLength);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * This functions produces an specific at function which is created for an individual identity of points.\r\n *\r\n * Speed differences:\r\n * - Building the whole body for each function: 140k ops/sec\r\n * - Using RegEx: 130k ops/sec\r\n * - Caching the positions of points[p][d] (this func): 230k ops/sec\r\n *\r\n */\r\nexport function produceSpecificAtFunction(points: number[][]): SpecificAtFunction {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n\r\n    // the generic function is the base for the specific one\r\n    const generic = produceGenericAtFunction(grade, dimension);\r\n\r\n    // const generic = fCache[grade][dimension];\r\n    let orig = generic.body;\r\n\r\n    // if this generic function was never used for a specific one it\r\n    // is missing the pointsPositions which will now be created and cached\r\n    if (generic.pointsPositions == undefined)\r\n        generic.pointsPositions = getPlaces(orig);\r\n\r\n    // places now contains the array described in fCache.pointsPositions\r\n    const places = generic.pointsPositions;\r\n\r\n\r\n    let newFuncBody = \"\";\r\n    for (let i = 0; i < places.length; i++) {\r\n        // every even element is a string which separates two occurrences of point[p][d]\r\n        if (i % 2 == 0) {\r\n            newFuncBody += places[i] as string;\r\n        } else { // every odd one is an object which has to be replaced by the numeric value in points[p][d] (the function argument)\r\n            const para = places[i] as { point: number, dimension: number };\r\n            newFuncBody += '' + points[para.point][para.dimension];\r\n        }\r\n    }\r\n\r\n    return Function('t', newFuncBody) as SpecificAtFunction;\r\n}","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Complex {\r\n    constructor(re, im) {\r\n        this.re = re || 0;\r\n        this.im = im || 0;\r\n    }\r\n}\r\n/**\r\n * Multiplies the complex numbers a and b.\r\n */\r\nComplex.multiply = function multiply(a, b) {\r\n    return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + b.re * a.im);\r\n};\r\n/**\r\n * Adds Complex a to Complex b\r\n */\r\nComplex.add = function add(a, b) {\r\n    return new Complex(a.re + b.re, a.im + b.im);\r\n};\r\n/**\r\n * Divide a complex number by an real number\r\n *\r\n * n / c\r\n *\r\n * divideNCompl(3, new Complex(2, -5)) == 3 / (2 - 5i)\r\n */\r\nComplex.divideNCompl = function divideNCompl(n, c) {\r\n    const nDivByk = n / (c.re * c.re + c.im * c.im);\r\n    return new Complex(c.re * nDivByk, -c.im * nDivByk);\r\n};\r\n/**\r\n * Calculates the complex nth-roots of the given complex number.\r\n */\r\nComplex.root = function root(c, n) {\r\n    const a = c.re;\r\n    const b = c.im;\r\n    // length of the complex number \r\n    const r = Math.sqrt(a * a + b * b);\r\n    const phi = Math.acos(a / r);\r\n    const roots = new Array(n);\r\n    const nthRootOfR1 = Math.pow(r, 1 / n);\r\n    const nthRootOfR2 = (b < 0 ? -nthRootOfR1 : nthRootOfR1);\r\n    for (let k = 0; k < n; k++) {\r\n        const d = (k * 2 * Math.PI + phi) / n;\r\n        roots[k] = new Complex(nthRootOfR1 * Math.cos(d), nthRootOfR2 * Math.sin(d));\r\n    }\r\n    return roots;\r\n};\r\n/**\r\n * Is a simplified variant of the root(), which is somewhat faster and only returns the first root.\r\n */\r\nComplex.cubicRoot = function cubicRoot(c) {\r\n    const a = c.re;\r\n    const b = c.im;\r\n    // length of the complex number \r\n    const r = Math.sqrt(a * a + b * b);\r\n    const nthRootOfR1 = Math.pow(r, 1 / 3);\r\n    const nthRootOfR2 = (b < 0 ? -nthRootOfR1 : nthRootOfR1);\r\n    const d = Math.acos(a / r) / 3;\r\n    return new Complex(nthRootOfR1 * Math.cos(d), nthRootOfR2 * Math.sin(d));\r\n};\r\nexports.default = Complex;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst complex_js_1 = require(\"./complex.js\");\r\n/**\r\n * Solves 0 = a*x + b for x\r\n */\r\nfunction solveLinearEquation(a, b) {\r\n    if (a == 0)\r\n        if (b != 0)\r\n            return [];\r\n        else\r\n            return [0];\r\n    else\r\n        return [-b / a];\r\n}\r\nexports.solveLinearEquation = solveLinearEquation;\r\n/**\r\n * Solves 0 = a*x^2 + b*x + c for x\r\n */\r\nfunction solveQuadraticEquation(a, b, c) {\r\n    if (a == 0)\r\n        return solveLinearEquation(b, c);\r\n    const p = b / a;\r\n    const q = c / a;\r\n    const sqrtContent = p / 2 * p / 2 - q;\r\n    if (sqrtContent < 0) {\r\n        const sqrtR = Math.sqrt(-sqrtContent);\r\n        return [new complex_js_1.default(-p / 2, sqrtR), new complex_js_1.default(-p / 2, -sqrtR)];\r\n    }\r\n    else {\r\n        const sqrtR = Math.sqrt(sqrtContent);\r\n        return [-p / 2 + sqrtR, -p / 2 - sqrtR];\r\n    }\r\n}\r\nexports.solveQuadraticEquation = solveQuadraticEquation;\r\nconst c1Multi = new complex_js_1.default(-0.5, 0.5 * Math.sqrt(3));\r\nconst c2Multi = new complex_js_1.default(-0.5, -0.5 * Math.sqrt(3));\r\nfunction calcC(d0, d1) {\r\n    const sqrtContent = d1 * d1 - 4 * d0 * d0 * d0;\r\n    if (sqrtContent < 0) {\r\n        const imaginaryPart = Math.sqrt(-sqrtContent) / 2;\r\n        const realPart = d1 / 2;\r\n        // you could also use Complex.root to get all roots, to prevent the usage of \r\n        // multiplications for c1 and c2 in solveCubicEquation\r\n        // const [c0,c1,c2] = Complex.root(new Complex(realPart, imaginaryPart), 3);\r\n        return complex_js_1.default.cubicRoot(new complex_js_1.default(realPart, imaginaryPart));\r\n    }\r\n    else {\r\n        return new complex_js_1.default(Math.cbrt((d1 + Math.sqrt(sqrtContent)) / 2), 0);\r\n    }\r\n}\r\nfunction calcX(d0, c, a, b) {\r\n    // -1 / (3 * a) * (b + c + d / c)\r\n    const dDivc = complex_js_1.default.divideNCompl(d0, c);\r\n    const res = new complex_js_1.default(-(dDivc.re + c.re + b) / (3 * a), -(dDivc.im + c.im) / (3 * a));\r\n    return res;\r\n}\r\n/**\r\n * Solves 0 = a*x^3 + b*x^2 + c*x + d for x\r\n */\r\nfunction solveCubicEquation(a, b, c, d) {\r\n    if (a == 0)\r\n        return solveQuadraticEquation(b, c, d);\r\n    if (d == 0) {\r\n        const x = solveQuadraticEquation(a, b, c);\r\n        const y = [0];\r\n        const l = x.length;\r\n        if (l > 0) {\r\n            y[1] = x[0];\r\n            if (l > 1) {\r\n                y[2] = x[1];\r\n            }\r\n        }\r\n        return y;\r\n    }\r\n    const delta0 = b * b -\r\n        3 * a * c;\r\n    const delta1 = 2 * b * b * b -\r\n        9 * a * b * c +\r\n        27 * a * a * d;\r\n    // const delta = 18 * a * b * c * d -\r\n    //     4 * b * b * b * d +\r\n    //     b * b * c * c -\r\n    //     4 * a * c * c * c -\r\n    //     27 * a * a * d * d;\r\n    const c0 = calcC(delta0, delta1);\r\n    const c1 = complex_js_1.default.multiply(c0, c1Multi);\r\n    const c2 = complex_js_1.default.multiply(c0, c2Multi);\r\n    const x0 = calcX(delta0, c0, a, b);\r\n    const x1 = calcX(delta0, c1, a, b);\r\n    const x2 = calcX(delta0, c2, a, b);\r\n    return [x0, x1, x2];\r\n}\r\nexports.solveCubicEquation = solveCubicEquation;\r\n","import {solveCubicEquation, solveLinearEquation, solveQuadraticEquation} from 'linear-quadratic-cubic-eq-solver';\r\nimport Complex from \"linear-quadratic-cubic-eq-solver/cjs/complex\";\r\n\r\n/**\r\n *\r\n * @param is the value the value is currently\r\n * @param should what value `is` should be\r\n * @param margin how far away the the value is allowed to be from the `should` result\r\n *\r\n * @returns < 0 if `is` is below the range of should - margin\r\n *          > 0 if `is` is above the range of should + margin\r\n *          = 0 if `is` is withing in the range\r\n */\r\nconst inRange = (is: number, should: number, margin: number): number => {\r\n    const spm = should + margin\r\n    if (is > spm)\r\n        return is - spm;\r\n\r\n    const smm = should - margin\r\n    if (is < smm)\r\n        return is - smm;\r\n\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Removes complex numbers and converts complex numbers with an imaginary part of smaller than 1e-8 to a real number.\r\n * @param n\r\n */\r\nconst cleanSolutions = (n: (number | Complex)[]): number[] => {\r\n    const k: number[] = [];\r\n\r\n    for (const h of n) {\r\n        if (typeof h == 'number')\r\n            k.push(h);\r\n        else if (inRange(h.im, 0, 1e-8) == 0)\r\n            k.push(h.re);\r\n\r\n    }\r\n\r\n    return k as number[];\r\n}\r\n\r\ntype Solver = (p: number[], f: number) => number[];\r\n\r\nconst solvingFunctions: Solver[] = [\r\n    (p, f) => {\r\n        const a = p[1] - p[0];\r\n        const b = p[0] - f;\r\n\r\n        return cleanSolutions(solveLinearEquation(a, b));\r\n    },\r\n\r\n    (p, f) => {\r\n        const a = p[0] - 2 * p[1] + p[2];\r\n        const b = -2 * p[0] + 2 * p[1];\r\n        const c = p[0] - f;\r\n\r\n        return cleanSolutions(solveQuadraticEquation(a, b, c));\r\n    },\r\n\r\n    (p, f) => {\r\n        const a = -p[0] + 3 * p[1] - 3 * p[2] + p[3];\r\n        const b = 3 * p[0] - 6 * p[1] + 3 * p[2];\r\n        const c = -3 * p[0] + 3 * p[1];\r\n        const d = p[0] - f;\r\n\r\n        return cleanSolutions(solveCubicEquation(a, b, c, d));\r\n    }\r\n]\r\n\r\nexport function createDeterministicTSearch(points: number[][]) {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n\r\n    if (grade == null || grade < 2 || grade > 4)\r\n        return null;\r\n\r\n    const dimensionalSplit: number[][] = [];\r\n\r\n    for (let d = 0; d < dimension; d++) {\r\n        const ds: number[] = [];\r\n\r\n        for (let p = 0; p < points.length; p++)\r\n            ds.push(points[p][d]);\r\n\r\n        dimensionalSplit.push(ds);\r\n    }\r\n\r\n    const func = solvingFunctions[grade - 2];\r\n\r\n    return (v: number, d: number) => {\r\n        return func(dimensionalSplit[d], v);\r\n    }\r\n}","import {produceSpecificAtFunction} from \"./produce-specific-at\";\r\nimport {createDeterministicTSearch} from \"./deterministic-t-search\";\r\n\r\nconst createSpecificAtFunction = (points: number[][]) => {\r\n    const at = produceSpecificAtFunction(points);\r\n\r\n    if (at == null)\r\n        throw new Error(\"could not create specific function for points \" + JSON.stringify(points));\r\n\r\n    return at;\r\n};\r\n\r\nconst createDetermenisticTSearchFunction = (points: number[][]) => {\r\n    const tSearch = createDeterministicTSearch(points);\r\n\r\n    if (tSearch == null)\r\n        throw new Error(\"could not create deterministic function for points \" + JSON.stringify(points));\r\n\r\n    return tSearch;\r\n}\r\n\r\nexport class StaticBezier {\r\n\r\n    constructor(points: number[][]) {\r\n        this.at = createSpecificAtFunction(points);\r\n        this.tSearch = createDetermenisticTSearchFunction(points);\r\n    }\r\n\r\n    at(t: number): number[] {\r\n        throw new Error();\r\n    }\r\n\r\n    tSearch(value: number, dimension: number) {\r\n        throw new Error();\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EventEmitter = void 0;\r\nconst LISTENERS = Symbol('LISTENERS');\r\nconst ensureBacking = (target) => {\r\n    const pd = Object.getOwnPropertyDescriptor(target, LISTENERS);\r\n    if (pd === undefined) {\r\n        const backing = Object.create(null);\r\n        Object.defineProperty(target, LISTENERS, {\r\n            value: backing,\r\n            configurable: false,\r\n            enumerable: false,\r\n            writable: false\r\n        });\r\n        return backing;\r\n    }\r\n    else\r\n        return pd.value;\r\n};\r\nconst getListeners = (target, name) => {\r\n    const backing = ensureBacking(target);\r\n    return name in backing ? backing[name] : backing[name] = [];\r\n};\r\nclass EventEmitter {\r\n    // ensureBacking & getListeners are not part of this class to keep the prototype as expected\r\n    addEventListener(name, listener) {\r\n        const listeners = getListeners(this, name);\r\n        listeners.push(listener);\r\n    }\r\n    // alias\r\n    on(name, listener) { }\r\n    addListener(name, listener) { }\r\n    subscribe(name, listener) { }\r\n    once(name, listener) {\r\n        const listenerWrapper = (ev) => {\r\n            this.removeEventListener(name, listenerWrapper);\r\n            listener(ev);\r\n        };\r\n        this.addEventListener(name, listenerWrapper);\r\n    }\r\n    waitFor(name) {\r\n        return new Promise(res => this.once(name, res));\r\n    }\r\n    emit(name, event) {\r\n        const listeners = getListeners(this, name);\r\n        // slicing to prevent issue with listener which manipulate the listener array\r\n        for (const listener of listeners.slice())\r\n            listener.call(this, event);\r\n    }\r\n    // alias\r\n    dispatch(name, event) { }\r\n    push(name, event) { }\r\n    publish(name, event) { }\r\n    removeEventListener(name, listener) {\r\n        const listeners = getListeners(this, name);\r\n        const index = listeners.indexOf(listener);\r\n        if (index == -1)\r\n            return false;\r\n        listeners.splice(index, 1);\r\n        return true;\r\n    }\r\n    // alias\r\n    off(name, listener) { return false; }\r\n    removeListener(name, listener) { return false; }\r\n    unsubscribe(name, listener) { return false; }\r\n}\r\nexports.EventEmitter = EventEmitter;\r\n// setting alias functions\r\nEventEmitter.prototype.on = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.addListener = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.subscribe = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.dispatch = EventEmitter.prototype.emit;\r\nEventEmitter.prototype.push = EventEmitter.prototype.dispatch;\r\nEventEmitter.prototype.publish = EventEmitter.prototype.dispatch;\r\nEventEmitter.prototype.off = EventEmitter.prototype.removeEventListener;\r\nEventEmitter.prototype.removeListener = EventEmitter.prototype.removeEventListener;\r\nEventEmitter.prototype.unsubscribe = EventEmitter.prototype.removeEventListener;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.makeEventEmitter = void 0;\r\nconst event_emitter_1 = require(\"./event-emitter\");\r\nconst eventEmitterPrototypeDesc = Object.getOwnPropertyDescriptors(event_emitter_1.EventEmitter.prototype);\r\ndelete eventEmitterPrototypeDesc.constructor;\r\n/**\r\n * Attaches the methods defined in the {@link EventEmitter} prototype to the prototype of the target.\r\n * The reason to manipulate the prototype instead of making it extend the EventEmitter is to keep the prototype chain as\r\n * it was.\r\n *\r\n * @throws This function will throw an Error if a property with the same name was already present on the prototype of\r\n * the target.\r\n *\r\n * @param target To manipulate the prototype of.\r\n */\r\nfunction makeEventEmitter(target) {\r\n    // not extending but adding those methods since it is not trivial to splice a prototype chain\r\n    const tp = target.prototype;\r\n    const targetPrototypeDesc = Object.getOwnPropertyDescriptors(tp);\r\n    for (const name in eventEmitterPrototypeDesc)\r\n        if (name in targetPrototypeDesc)\r\n            throw new Error(String(name) + ' was already present in the prototype of the target');\r\n    Object.defineProperties(tp, eventEmitterPrototypeDesc);\r\n}\r\nexports.makeEventEmitter = makeEventEmitter;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./event-emitter\"), exports);\r\n__exportStar(require(\"./event-emitter-int\"), exports);\r\n__exportStar(require(\"./make-event-emitter\"), exports);\r\n","// import {Vector2} from \"three\";\r\n\r\nexport type V2 = [number, number];\r\n\r\n// const av = new Vector2();\r\n// const aMv = new Vector2();\r\n//\r\n// const bv = new Vector2();\r\n// const bMv = new Vector2();\r\n//\r\n// const abv = new Vector2();\r\n// const aMbMv = new Vector2();\r\n\r\nconst distance = (a: V2, b: V2) => Math.sqrt((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2);\r\n\r\n/**\r\n * This function morphs all provided other points in such a way, that the relative position of all points (a, b and other)\r\n * is the same as (aMorphed, bMorphed and the returning points). You could image two layers, the first with the original\r\n * points and the second with the a copy of that layer. Then you would scale and rotate the second layer in such a way\r\n * that a of the second layer is in the position aMorphed and b is the position bMorphed.\r\n *\r\n * The position of all other points of this imaginary layer will be returned. Those are morphed as a and b were.\r\n *\r\n * @param a\r\n * @param aMorphed\r\n * @param b\r\n * @param bMorphed\r\n *\r\n * @param other\r\n */\r\nexport function fitSystem<Other extends V2[]>(a: V2, aMorphed: V2, b: V2, bMorphed: V2, other: Other): Other {\r\n    // calculate the scaling of the ab and aMorphedBMorphed\r\n    const scale = distance(aMorphed, bMorphed) / distance(a, b);\r\n\r\n    // scaled vector from a to b\r\n    const sab: V2 = [\r\n        // bMorphed[0] - aMorphed[0],\r\n        (b[0] - a[0]) * scale,\r\n        // bMorphed[1] - aMorphed[1]\r\n        (b[1] - a[1]) * scale\r\n    ];\r\n\r\n    const sinA = (bMorphed[1] - aMorphed[1] + (bMorphed[0] - aMorphed[0]) * sab[1] / sab[0]) *\r\n        sab[0] / (sab[0] * sab[0] - sab[1] * sab[1])\r\n\r\n    const cosA = Math.cos(Math.asin(sinA));\r\n\r\n    return other.map(([x, y]) => {\r\n        // get vector a to current point\r\n        const ac: V2 = [x - a[0], y - a[1]];\r\n\r\n        // apply same transform as for a to b\r\n        const morphedDelta = [\r\n            (cosA * scale * ac[0] - sinA * scale * ac[1]),\r\n            (sinA * scale * ac[0] + cosA * scale * ac[1])\r\n        ];\r\n\r\n        // apply morphed delta on a to get morphed c\r\n        return [\r\n            a[0] + morphedDelta[0],\r\n            a[1] + morphedDelta[1]\r\n        ];\r\n    }) as Other;\r\n}\r\n\r\nexport function fitSystemFixed<Other extends V2[]>(av: V2, aMorphed: V2, bv: V2, bMorphed: V2, other: Other): Other {\r\n    const a = av[0];\r\n    const b = av[1];\r\n\r\n    const i = bv[0];\r\n    const j = bv[1];\r\n\r\n    const g = aMorphed[0];\r\n    const h = aMorphed[1];\r\n\r\n    const k = bMorphed[0];\r\n    const l = bMorphed[1];\r\n\r\n    const d = (k - g * i / a) * a / (i * -b + j * a);\r\n    const f = (l - h * i / a) * a / (i * -b + j * a);\r\n\r\n    const c = (g - d * b) / a;\r\n    const e = (h - f * b) / a;\r\n\r\n    return other.map(([x, y]) => {\r\n        // get vector a to current point\r\n\r\n        // apply morphed delta on a to get morphed c\r\n        return [\r\n            x * c + y * d,\r\n            x * e + y * f\r\n        ];\r\n    }) as Other;\r\n}\r\n\r\nconst setLength = (v: V2, desLength = 1) => {\r\n    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1]);\r\n\r\n    return [\r\n        desLength * v[0] / length,\r\n        desLength * v[1] / length\r\n    ] as V2;\r\n}\r\n\r\nconst turn90Left = (v: V2) => {\r\n    return [\r\n        v[1],\r\n        -v[0]\r\n    ] as V2;\r\n}\r\n\r\nconst turn90Right = (v: V2) => {\r\n    return [\r\n        -v[1],\r\n        v[0]\r\n    ] as V2;\r\n}\r\n\r\nconst vecFromTo = (from: V2, to: V2) => {\r\n    return [\r\n        to[0] - from[0],\r\n        to[1] - from[1]\r\n    ] as V2;\r\n}\r\n\r\nconst add = (a: V2, b: V2) => {\r\n    return [\r\n        a[0] + b[0],\r\n        a[1] + b[1]\r\n    ] as V2;\r\n}\r\n\r\nconst isSame = (a: number, b: number, delta = 1e-8) => Math.abs(a - b) < delta;\r\n\r\nconst sameDirection = (a: V2, b: V2) => {\r\n    const aUnit = setLength(a, 1);\r\n    const bUnit = setLength(b, 1);\r\n\r\n\r\n    return (isSame(aUnit[0], bUnit[0]) && isSame(aUnit[1], bUnit[1])) ||\r\n        (isSame(aUnit[0], -bUnit[0]) && isSame(aUnit[1], -bUnit[1]));\r\n}\r\n\r\nconst multiply = (v: V2, scalar: number) => {\r\n    return [\r\n        v[0] * scalar,\r\n        v[1] * scalar\r\n    ];\r\n}\r\n\r\n\r\nconst intersection = (aBase: V2, aDirection: V2, bBase: V2, bDirection: V2): 'parallel-or-identical' | V2 => {\r\n    if (sameDirection(aDirection, bDirection))\r\n        return 'parallel-or-identical';\r\n\r\n    // would result in a == 0 which in turn would result in a division by 0\r\n    // so we just switch the args, they can both have a direction in y direction of 0\r\n    // since then they would have the same direction which is already tested\r\n    if (aDirection[1] == 0) {\r\n        const tempBase = aBase;\r\n        aBase = bBase;\r\n        bBase = tempBase;\r\n\r\n        const tempDirection = aDirection;\r\n        aDirection = bDirection;\r\n        bDirection = tempDirection;\r\n    }\r\n\r\n    const a_1_x = aBase[0];\r\n    const a_1_y = aBase[1];\r\n\r\n    const a_2_x = aBase[0] + aDirection[0];\r\n    const a_2_y = aBase[1] + aDirection[1];\r\n\r\n    const a = a_1_y - a_2_y;\r\n    const b = a_2_x - a_1_x;\r\n    const c = a_1_x * a_2_y - a_2_x * a_1_y;\r\n\r\n    const b_1_x = bBase[0];\r\n    const b_1_y = bBase[1];\r\n\r\n    const b_2_x = bBase[0] + bDirection[0];\r\n    const b_2_y = bBase[1] + bDirection[1];\r\n\r\n    const d = b_1_y - b_2_y;\r\n    const e = b_2_x - b_1_x;\r\n    const f = b_1_x * b_2_y - b_2_x * b_1_y;\r\n\r\n    const y = (d * c - f * a) / (a * e - d * b);\r\n    const x = (-c - b * y) / a;\r\n\r\n    return [x, y];\r\n}\r\n\r\nexport function fitSystemNewApproach<Other extends V2[]>(p: Other, direction: 'left' | 'right', distance: number): Other {\r\n    const turner = direction == 'left' ? turn90Left : turn90Right;\r\n    const otherTurner = direction == 'left' ? turn90Right : turn90Left;\r\n\r\n    const ret: Other = [] as any;\r\n\r\n    {\r\n        const toSecond = vecFromTo(p[0], p[1]);\r\n        const unitToSecond = setLength(toSecond, distance);\r\n        const offset = turner(unitToSecond);\r\n        ret.push(add(p[0], offset));\r\n    }\r\n\r\n    for (let i = 1; i < p.length - 1; i++) {\r\n        const fromLast = vecFromTo(p[i - 1], p[i]);\r\n        const fromLastBase = add(p[i - 1], setLength(turner(fromLast), distance));\r\n\r\n        const fromNext = vecFromTo(p[i + 1], p[i]);\r\n        const fromNextBase = add(p[i + 1], setLength(otherTurner(fromNext), distance));\r\n\r\n        const hitPoint = intersection(fromLastBase, fromLast, fromNextBase, fromNext);\r\n        if (typeof hitPoint == 'string')\r\n            // TODO handle straight piece\r\n            //  should just take straight up\r\n            ret.push(add(p[i], setLength(turner(fromLast), distance)));\r\n        else\r\n            ret.push(hitPoint);\r\n        // With same length between p[i] and morphed p[i]\r\n        // ret.push(add(p[i], setLength(vecFromTo(p[i], hitPoint), distance)));\r\n    }\r\n\r\n    {\r\n        const toLast = vecFromTo(p[p.length - 2], p[p.length - 1]);\r\n        const unitToSecond = setLength(toLast, distance);\r\n        const offset = turner(unitToSecond);\r\n        ret.push(add(p[p.length - 1], offset));\r\n    }\r\n\r\n    return ret;\r\n}","import {StaticBezier} from '../../nd-bezier/src/static-bezier';\r\n\r\nimport {EventEmitter} from \"event-emitter-typesafe\";\r\nimport {fitSystemNewApproach, V2} from \"./fit-system\";\r\n\r\nconst height = 900;\r\nconst width = 1400;\r\nconst margin = 100;\r\n\r\ntype Vector2 = [number, number];\r\n\r\n/*\r\nK(t) = a * t ^ b * (1 - t) ^ c\r\nK'(t) = a * b * t ^ (b - 1) * (1 - t) ^ c - a * c * t ^ b * (1 - t) ^ (c - 1)\r\n*/\r\n\r\n//\r\n// let bezierPoints: Vector2[] = [];\r\n//\r\nfunction ascent(points: Vector2[], t: number) {\r\n    \"use strict\";\r\n\r\n    const oneMinusT = 1 - t;\r\n    const m0 = -3 * oneMinusT * oneMinusT;\r\n    const m1 = 9 * t * t - 12 * t + 3;\r\n    const m2 = 6 * t - 9 * t * t;\r\n    const m3 = 3 * t * t;\r\n    return [\r\n        m0 * points[0][0] + m1 * points[1][0] + m2 * points[2][0] + m3 * points[3][0],\r\n        m0 * points[0][1] + m1 * points[1][1] + m2 * points[2][1] + m3 * points[3][1]\r\n    ];\r\n}\r\n\r\nconst pointRadius = 20;\r\n\r\nfunction drawPoints(ctx: CanvasRenderingContext2D, points: Vector2[], radius = pointRadius) {\r\n    ctx.beginPath();\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n        const p = points[i];\r\n        ctx.moveTo(p[0], p[1]);\r\n        ctx.arc(p[0], p[1], radius, 0, 360);\r\n    }\r\n\r\n    ctx.fill();\r\n    ctx.closePath();\r\n}\r\n\r\nfunction drawPolyline(ctx: CanvasRenderingContext2D, points: Vector2[]) {\r\n    if (points.length == 0)\r\n        return;\r\n\r\n    ctx.beginPath();\r\n\r\n    const startPoint = points[0];\r\n    ctx.moveTo(startPoint[0], startPoint[1]);\r\n    for (let i = 1; i < points.length; i++) {\r\n        const point = points[i];\r\n        ctx.lineTo(point[0], point[1]);\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n}\r\n\r\nfunction getPointsLeftAndRightFromBezier(points: Vector2[], t: number, distance: number): [V2, V2, V2] {\r\n    const asc = ascent(points, t);\r\n    const ascLength = Math.sqrt(asc[0] * asc[0] + asc[1] * asc[1]);\r\n    const ascNorm = [distance * asc[0] / ascLength, distance * asc[1] / ascLength];\r\n\r\n    let bezier = new StaticBezier(points);\r\n    const point = bezier.at(t);\r\n\r\n    return [\r\n        // left point\r\n        [point[0] + ascNorm[1], point[1] + -ascNorm[0]],\r\n\r\n        // center point\r\n        [point[0], point[1]],\r\n\r\n        // right point\r\n        [point[0] + -ascNorm[1], point[1] + ascNorm[0]]\r\n    ];\r\n}\r\n\r\nfunction drawOffsetBezier(ctx: CanvasRenderingContext2D, pinPoints: V2[], spikes: number, distance: number, renderSpikes: boolean) {\r\n    if (spikes == 0 || pinPoints.length != 4)\r\n        return;\r\n\r\n    const rightSideLines: [Vector2, Vector2][] = [];\r\n    const leftSideLines: [Vector2, Vector2][] = [];\r\n\r\n    for (let i = 0; i <= spikes; i++) {\r\n        const t = i / spikes;\r\n        const [left, center, right] = getPointsLeftAndRightFromBezier(pinPoints, t, distance);\r\n\r\n        rightSideLines.push([\r\n            center,\r\n            right\r\n        ]);\r\n\r\n        leftSideLines.push([\r\n            center,\r\n            left\r\n        ]);\r\n    }\r\n\r\n    const originalStrokeStyle = ctx.strokeStyle;\r\n\r\n    ctx.strokeStyle = '#444';\r\n    drawPolyline(ctx, rightSideLines.map(p => p[1]));\r\n\r\n    // ctx.strokeStyle = '#f00';\r\n    // drawPolyline(ctx, rightSideLines.map(p => [\r\n    //     (p[0][0] + p[1][0]) / 2,\r\n    //     (p[0][1] + p[1][1]) / 2\r\n    // ]));\r\n\r\n\r\n    ctx.strokeStyle = '#444';\r\n    drawPolyline(ctx, leftSideLines.map(p => p[1]));\r\n\r\n    // ctx.strokeStyle = '#f00';\r\n    // drawPolyline(ctx, leftSideLines.map(p => [\r\n    //     (p[0][0] + p[1][0]) / 2,\r\n    //     (p[0][1] + p[1][1]) / 2\r\n    // ]));\r\n\r\n\r\n    if (renderSpikes) {\r\n        const originalWidth = ctx.lineWidth;\r\n        ctx.strokeStyle = '#0ff';\r\n        ctx.lineWidth = originalWidth / 2;\r\n        ctx.beginPath();\r\n        for (const arr of [leftSideLines, rightSideLines]) {\r\n            for (const [start, end] of arr) {\r\n                ctx.moveTo(start[0], start[1]);\r\n                ctx.lineTo(end[0], end[1]);\r\n            }\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        ctx.lineWidth = originalWidth;\r\n    }\r\n\r\n    ctx.strokeStyle = originalStrokeStyle;\r\n}\r\n\r\nfunction drawBezier(pinPoints: Vector2[], ctx: CanvasRenderingContext2D, lines: number, spikes = lines) {\r\n    if (pinPoints.length < 2 || pinPoints.length > 4)\r\n        return;\r\n\r\n    const bezier = new StaticBezier(pinPoints);\r\n    const points: Vector2[] = [];\r\n\r\n    for (let i = 0; i <= lines; i++) {\r\n        points.push(bezier.at(i / lines) as Vector2);\r\n    }\r\n\r\n    drawPolyline(ctx, points);\r\n}\r\n\r\nconst options = {\r\n    spikes: [\"Spikes for offset Beziér\", false],\r\n    attachedCoords: [\"Write coordinates attached to node\", false]\r\n}\r\n\r\nfunction getOption(key: keyof typeof options) {\r\n    return options[key][1] as boolean;\r\n}\r\n\r\nconst frm = new Intl.NumberFormat('en-US', {\r\n    minimumFractionDigits: 2,\r\n    maximumFractionDigits: 2,\r\n    useGrouping: false\r\n}).format;\r\n\r\nconst nrFrm = (nr: number) => frm(nr).padStart(7, ' ');\r\nconst arrFrm = (arr: number[]) => '[' + arr.map(nrFrm).join(', ') + ']';\r\n\r\nlet debugElem!: HTMLOutputElement;\r\nlet context!: CanvasRenderingContext2D;\r\n\r\ntype FillStyle = CanvasRenderingContext2D[\"fillStyle\"];\r\n\r\nexport function debug(point: V2, name: string, dotColor: FillStyle = 'black', textColor: FillStyle = 'black', radius: number = pointRadius) {\r\n    if (!debugElem || !context)\r\n        return;\r\n\r\n    const frmPos = arrFrm(point);\r\n    debugElem.innerText += name + ': ' + frmPos + '\\n';\r\n\r\n    const originalFill = context.fillStyle;\r\n\r\n    context.fillStyle = dotColor;\r\n    drawPoints(context, [point]);\r\n\r\n    context.fillStyle = textColor;\r\n    context.textAlign = 'left';\r\n    context.textBaseline = 'bottom';\r\n    const str = getOption(\"attachedCoords\") ? name + ' ' + frmPos : name;\r\n    context.fillText(str, point[0] + radius, point[1] - radius);\r\n\r\n    context.fillStyle = originalFill;\r\n}\r\n\r\n\r\nfunction initialize() {\r\n    const debugOutput = document.getElementById('debug-output') as HTMLOutputElement;\r\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\r\n    const optionContainer = document.getElementById('control') as HTMLDivElement;\r\n\r\n    debugElem = debugOutput;\r\n\r\n    canvas.setAttribute('height', height + '');\r\n    canvas.setAttribute('width', width + '');\r\n\r\n\r\n    for (const key of Object.keys(options)) {\r\n        const [description, defaultValue] = (options as any)[key];\r\n        const checkbox = document.createElement('input');\r\n        const id = \"option-\" + key;\r\n        checkbox.id = id;\r\n        checkbox.type = \"checkbox\";\r\n        checkbox.checked = defaultValue;\r\n\r\n        const label = document.createElement('label');\r\n        label.innerText = description;\r\n        label.htmlFor = id;\r\n\r\n        const wrapper = document.createElement('div');\r\n        wrapper.className = \"option-wrapper\";\r\n\r\n        wrapper.append(checkbox, label);\r\n\r\n        optionContainer.append(wrapper);\r\n\r\n        checkbox.addEventListener('change', () => (options as any)[key][1] = checkbox.checked);\r\n    }\r\n\r\n    const getCanvasPosition = (() => {\r\n        let cache: undefined | ClientRect = undefined;\r\n\r\n        const invalidate = () => {\r\n            requestAnimationFrame(invalidate);\r\n            cache = undefined;\r\n        }\r\n        invalidate();\r\n\r\n        return function getCanvasPosition() {\r\n            if (cache)\r\n                return cache;\r\n\r\n            return cache = canvas.getBoundingClientRect()\r\n        }\r\n    })();\r\n\r\n    function mapPosition(ev: MouseEvent) {\r\n        const rect = getCanvasPosition();\r\n\r\n        return [\r\n            ev.clientX - rect.left,\r\n            ev.clientY - rect.top\r\n        ] as Vector2;\r\n    }\r\n\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    if (!ctx)\r\n        throw new Error('Could not initialize');\r\n\r\n    context = ctx;\r\n\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = \"#000\";\r\n\r\n    const awaitFrame = () => new Promise(res => requestAnimationFrame(res));\r\n\r\n\r\n    interface MouseEvents {\r\n        \"click\": { type: \"click\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"dragstart\": { type: \"dragstart\", original: MouseEvent, position: Vector2 };\r\n        \"drag\": { type: \"drag\", original: MouseEvent, position: Vector2, previous: Vector2 };\r\n        \"dragend\": { type: \"dragend\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"mousedown\": { type: \"mousedown\", original: MouseEvent, position: Vector2 };\r\n        \"mouseup\": { type: \"mouseup\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"mousemove\": { type: \"mousemove\", original: MouseEvent, position: Vector2 };\r\n    }\r\n\r\n    const mouseEvents = new EventEmitter<MouseEvents>();\r\n\r\n    document.addEventListener(\"mousemove\", ev =>\r\n        mouseEvents.emit(\"mousemove\", {type: \"mousemove\", original: ev, position: mapPosition(ev)}));\r\n\r\n    document.addEventListener(\"mousedown\", ev =>\r\n        mouseEvents.emit(\"mousedown\", {type: \"mousedown\", original: ev, position: mapPosition(ev)}));\r\n\r\n    document.addEventListener(\"mouseup\", ev =>\r\n        mouseEvents.emit(\"mouseup\", {type: \"mouseup\", original: ev, position: mapPosition(ev)}));\r\n\r\n    let lastMouseDownPos: Vector2 | undefined = undefined;\r\n    let emittedDragStart = false;\r\n\r\n    mouseEvents.addEventListener(\"mousedown\", ev => {\r\n        lastMouseDownPos = ev.position;\r\n        emittedDragStart = false;\r\n    });\r\n\r\n    mouseEvents.addEventListener(\"mouseup\", ev => {\r\n        lastMouseDownPos = undefined;\r\n        if (emittedDragStart)\r\n            mouseEvents.emit(\"dragend\", {\r\n                type: \"dragend\",\r\n                original: ev.original,\r\n                position: ev.position\r\n            })\r\n        else\r\n            mouseEvents.emit(\"click\", {\r\n                type: \"click\",\r\n                original: ev.original,\r\n                position: ev.position\r\n            })\r\n    });\r\n\r\n    let mousePosition: V2 | undefined = undefined;\r\n\r\n    mouseEvents.addEventListener(\"mousemove\", ev => {\r\n        mousePosition = ev.position;\r\n        if (ev.original.buttons > 0 && lastMouseDownPos) {\r\n            const lmdp = lastMouseDownPos;\r\n            lastMouseDownPos = ev.position;\r\n\r\n            if (!emittedDragStart) {\r\n                emittedDragStart = true;\r\n                mouseEvents.emit(\"dragstart\", {\r\n                    type: \"dragstart\",\r\n                    original: ev.original,\r\n                    position: ev.position\r\n                });\r\n            } else {\r\n                mouseEvents.emit(\"drag\", {\r\n                    type: \"drag\",\r\n                    original: ev.original,\r\n                    position: ev.position,\r\n                    previous: lmdp\r\n                })\r\n            }\r\n        }\r\n    })\r\n\r\n    type Values<T> = T extends object ? T extends { [key in keyof T]: infer V } ? V : never : never;\r\n\r\n    let occurredEvents = [] as Values<MouseEvents>[];\r\n\r\n    mouseEvents.addEventListener(\"click\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"dragstart\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"drag\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"dragend\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mousedown\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mouseup\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mousemove\", ev => occurredEvents.push(ev));\r\n\r\n    const distance = 100;\r\n    const bezierWidth = 800 + distance;\r\n    const bezierHeight = 500 + distance * 2;\r\n\r\n    const top = (height - bezierHeight) / 2;\r\n    const left = (width - bezierWidth) / 2;\r\n    const bottom = height - top;\r\n    const right = width - left;\r\n\r\n    let setPoints = [\r\n        [left + distance / 2, top + distance],\r\n        [right - distance / 2, top + distance],\r\n        [right - distance / 2, bottom - distance],\r\n        [left + distance / 2, bottom - distance]\r\n    ] as Vector2[];\r\n\r\n    function getHitPoint(points: Vector2[], pos: Vector2, range: number): number | undefined {\r\n\r\n        for (let i = 0; i < points.length; i++) {\r\n            const point = points[i];\r\n            const deltaX = point[0] - pos[0];\r\n            const deltaY = point[1] - pos[1];\r\n\r\n            if ((deltaX * deltaX + deltaY * deltaY) <= range * range)\r\n                return i;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    let draggedNodeIndex: undefined | number;\r\n\r\n    function indexToLetter(nr: number) {\r\n        return String.fromCharCode('a'.charCodeAt(0) + nr);\r\n    }\r\n\r\n    ctx.font = `15px Verdana`;\r\n\r\n    const start = Date.now();\r\n    (async () => {\r\n        while (true) {\r\n            const delta = Date.now() - start;\r\n\r\n            const perc = (Math.sin(delta / 10000 * Math.PI) + 1) / 2;\r\n            ctx.clearRect(0, 0, width, height);\r\n            debugElem.innerText = '';\r\n\r\n            interface CombinedDragCommand {\r\n                start: boolean;\r\n                progressed: boolean;\r\n                ended: boolean;\r\n\r\n                startPosition: Vector2;\r\n                endPosition: Vector2;\r\n            }\r\n\r\n            const combinedDragCommands: CombinedDragCommand[] = [];\r\n            let currentDrag: CombinedDragCommand | undefined = undefined;\r\n\r\n            for (const event of occurredEvents) {\r\n                if (event.type == \"dragstart\") {\r\n                    currentDrag = {\r\n                        start: true,\r\n                        progressed: false,\r\n                        ended: false,\r\n\r\n                        startPosition: event.position,\r\n                        endPosition: event.position\r\n                    };\r\n                } else if (event.type == \"drag\") {\r\n                    if (currentDrag) {\r\n                        currentDrag.progressed = true;\r\n                        currentDrag.endPosition = event.position;\r\n                    } else {\r\n                        // when the drag started before this frame\r\n                        currentDrag = {\r\n                            start: false,\r\n                            progressed: true,\r\n                            ended: false,\r\n\r\n                            startPosition: event.previous,\r\n                            endPosition: event.position\r\n                        };\r\n                    }\r\n                } else if (event.type == \"dragend\") {\r\n                    if (currentDrag) {\r\n                        currentDrag.ended = true;\r\n                        currentDrag.endPosition = event.position;\r\n                        combinedDragCommands.push(currentDrag);\r\n                        currentDrag = undefined;\r\n                    } else {\r\n                        // if the drag ends without any movement in this frame\r\n                        combinedDragCommands.push({\r\n                            start: false,\r\n                            progressed: false,\r\n                            ended: true,\r\n\r\n                            startPosition: event.position,\r\n                            endPosition: event.position\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentDrag)\r\n                combinedDragCommands.push(currentDrag);\r\n\r\n            for (const dragCommand of combinedDragCommands) {\r\n                if (draggedNodeIndex == undefined)\r\n                    draggedNodeIndex = getHitPoint(setPoints, dragCommand.startPosition, pointRadius);\r\n\r\n                if (draggedNodeIndex != undefined) {\r\n                    const deltaX = dragCommand.endPosition[0] - dragCommand.startPosition[0];\r\n                    const deltaY = dragCommand.endPosition[1] - dragCommand.startPosition[1];\r\n\r\n                    const point = setPoints[draggedNodeIndex];\r\n\r\n                    // console.log('hotted point', hotPoint, point);\r\n                    point[0] += deltaX;\r\n                    point[1] += deltaY;\r\n\r\n                    if (dragCommand.ended)\r\n                        draggedNodeIndex = undefined;\r\n                }\r\n            }\r\n\r\n            if (draggedNodeIndex != undefined) {\r\n                canvas.style.cursor = 'grabbing';\r\n            } else if (mousePosition) {\r\n                if (getHitPoint(setPoints, mousePosition, pointRadius) != undefined)\r\n                    canvas.style.cursor = 'grab';\r\n                else\r\n                    canvas.style.cursor = 'default';\r\n            }\r\n\r\n            for (const event of occurredEvents) {\r\n                if (event.type == \"click\") {\r\n                    // if (setPoints.length == 4)\r\n                    //     setPoints.shift();\r\n                    //\r\n                    // setPoints.push(event.position);\r\n                }\r\n            }\r\n\r\n            occurredEvents = [];\r\n\r\n            const numberOfLines = 40;\r\n\r\n            if (setPoints.length == 4) {\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.lineWidth = 4;\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n                drawBezier(setPoints, ctx, numberOfLines);\r\n\r\n                drawOffsetBezier(ctx, setPoints, numberOfLines, distance, getOption(\"spikes\"));\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n                for (const side of ['left', 'right']) {\r\n                    const morphed = fitSystemNewApproach(setPoints, side as any, distance);\r\n                    ctx.lineWidth = 4;\r\n                    ctx.strokeStyle = \"#f0a\";\r\n\r\n                    drawBezier(morphed, ctx, numberOfLines, 0);\r\n                    ctx.setLineDash([8, 8]);\r\n                    drawPolyline(ctx, morphed);\r\n                    ctx.setLineDash([]);\r\n\r\n                    for (let i = 0; i < morphed.length; i++)\r\n                        debug(morphed[i], indexToLetter(i) + '_morphed_' + side);\r\n                }\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n                drawPolyline(ctx, setPoints);\r\n\r\n                for (let i = 0; i < setPoints.length; i++)\r\n                    debug(setPoints[i], indexToLetter(i), draggedNodeIndex == i ? 'red' : 'orange');\r\n            }\r\n\r\n            await awaitFrame();\r\n        }\r\n    })()\r\n\r\n\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', initialize);"]}