{"version":3,"sources":["node_modules/event-emitter-typesafe/lib/event-emitter.js","node_modules/event-emitter-typesafe/lib/event-emitter-int.js","node_modules/event-emitter-typesafe/lib/make-event-emitter.js","node_modules/event-emitter-typesafe/lib/index.js","src/fit-system.ts","node_modules/nd-bezier/lib/math-functions.js","node_modules/nd-bezier/lib/cache.js","node_modules/nd-bezier/lib/produce-generic.js","node_modules/nd-bezier/lib/find-points-places.js","node_modules/nd-bezier/lib/produce-specific.js","node_modules/linear-quadratic-cubic-eq-solver/cjs/complex.js","node_modules/linear-quadratic-cubic-eq-solver/cjs/index.js","node_modules/nd-bezier/lib/deterministic-t-search.js","node_modules/nd-bezier/lib/static-bezier.js","src/interactive.ts"],"names":[],"mappings":"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","file":"interactive.1d97a26b.js","sourceRoot":"..","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EventEmitter = void 0;\r\nconst LISTENERS = Symbol('LISTENERS');\r\nconst ensureBacking = (target) => {\r\n    const pd = Object.getOwnPropertyDescriptor(target, LISTENERS);\r\n    if (pd === undefined) {\r\n        const backing = Object.create(null);\r\n        Object.defineProperty(target, LISTENERS, {\r\n            value: backing,\r\n            configurable: false,\r\n            enumerable: false,\r\n            writable: false\r\n        });\r\n        return backing;\r\n    }\r\n    else\r\n        return pd.value;\r\n};\r\nconst getListeners = (target, name) => {\r\n    const backing = ensureBacking(target);\r\n    return name in backing ? backing[name] : backing[name] = [];\r\n};\r\nclass EventEmitter {\r\n    // ensureBacking & getListeners are not part of this class to keep the prototype as expected\r\n    addEventListener(name, listener) {\r\n        const listeners = getListeners(this, name);\r\n        listeners.push(listener);\r\n    }\r\n    // alias\r\n    on(name, listener) { }\r\n    addListener(name, listener) { }\r\n    subscribe(name, listener) { }\r\n    once(name, listener) {\r\n        const listenerWrapper = (ev) => {\r\n            this.removeEventListener(name, listenerWrapper);\r\n            listener(ev);\r\n        };\r\n        this.addEventListener(name, listenerWrapper);\r\n    }\r\n    waitFor(name) {\r\n        return new Promise(res => this.once(name, res));\r\n    }\r\n    emit(name, event) {\r\n        const listeners = getListeners(this, name);\r\n        // slicing to prevent issue with listener which manipulate the listener array\r\n        for (const listener of listeners.slice())\r\n            listener.call(this, event);\r\n    }\r\n    // alias\r\n    dispatch(name, event) { }\r\n    push(name, event) { }\r\n    publish(name, event) { }\r\n    removeEventListener(name, listener) {\r\n        const listeners = getListeners(this, name);\r\n        const index = listeners.indexOf(listener);\r\n        if (index == -1)\r\n            return false;\r\n        listeners.splice(index, 1);\r\n        return true;\r\n    }\r\n    // alias\r\n    off(name, listener) { return false; }\r\n    removeListener(name, listener) { return false; }\r\n    unsubscribe(name, listener) { return false; }\r\n}\r\nexports.EventEmitter = EventEmitter;\r\n// setting alias functions\r\nEventEmitter.prototype.on = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.addListener = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.subscribe = EventEmitter.prototype.addEventListener;\r\nEventEmitter.prototype.dispatch = EventEmitter.prototype.emit;\r\nEventEmitter.prototype.push = EventEmitter.prototype.dispatch;\r\nEventEmitter.prototype.publish = EventEmitter.prototype.dispatch;\r\nEventEmitter.prototype.off = EventEmitter.prototype.removeEventListener;\r\nEventEmitter.prototype.removeListener = EventEmitter.prototype.removeEventListener;\r\nEventEmitter.prototype.unsubscribe = EventEmitter.prototype.removeEventListener;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.makeEventEmitter = void 0;\r\nconst event_emitter_1 = require(\"./event-emitter\");\r\nconst eventEmitterPrototypeDesc = Object.getOwnPropertyDescriptors(event_emitter_1.EventEmitter.prototype);\r\ndelete eventEmitterPrototypeDesc.constructor;\r\n/**\r\n * Attaches the methods defined in the {@link EventEmitter} prototype to the prototype of the target.\r\n * The reason to manipulate the prototype instead of making it extend the EventEmitter is to keep the prototype chain as\r\n * it was.\r\n *\r\n * @throws This function will throw an Error if a property with the same name was already present on the prototype of\r\n * the target.\r\n *\r\n * @param target To manipulate the prototype of.\r\n */\r\nfunction makeEventEmitter(target) {\r\n    // not extending but adding those methods since it is not trivial to splice a prototype chain\r\n    const tp = target.prototype;\r\n    const targetPrototypeDesc = Object.getOwnPropertyDescriptors(tp);\r\n    for (const name in eventEmitterPrototypeDesc)\r\n        if (name in targetPrototypeDesc)\r\n            throw new Error(String(name) + ' was already present in the prototype of the target');\r\n    Object.defineProperties(tp, eventEmitterPrototypeDesc);\r\n}\r\nexports.makeEventEmitter = makeEventEmitter;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./event-emitter\"), exports);\r\n__exportStar(require(\"./event-emitter-int\"), exports);\r\n__exportStar(require(\"./make-event-emitter\"), exports);\r\n","// import {Vector2} from \"three\";\r\n\r\nexport type V2 = [number, number];\r\n\r\n// const av = new Vector2();\r\n// const aMv = new Vector2();\r\n//\r\n// const bv = new Vector2();\r\n// const bMv = new Vector2();\r\n//\r\n// const abv = new Vector2();\r\n// const aMbMv = new Vector2();\r\n\r\nconst distance = (a: V2, b: V2) => Math.sqrt((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2);\r\n\r\n/**\r\n * This function morphs all provided other points in such a way, that the relative position of all points (a, b and other)\r\n * is the same as (aMorphed, bMorphed and the returning points). You could image two layers, the first with the original\r\n * points and the second with the a copy of that layer. Then you would scale and rotate the second layer in such a way\r\n * that a of the second layer is in the position aMorphed and b is the position bMorphed.\r\n *\r\n * The position of all other points of this imaginary layer will be returned. Those are morphed as a and b were.\r\n *\r\n * @param a\r\n * @param aMorphed\r\n * @param b\r\n * @param bMorphed\r\n *\r\n * @param other\r\n */\r\nexport function fitSystem<Other extends V2[]>(a: V2, aMorphed: V2, b: V2, bMorphed: V2, other: Other): Other {\r\n    // calculate the scaling of the ab and aMorphedBMorphed\r\n    const scale = distance(aMorphed, bMorphed) / distance(a, b);\r\n\r\n    // scaled vector from a to b\r\n    const sab: V2 = [\r\n        // bMorphed[0] - aMorphed[0],\r\n        (b[0] - a[0]) * scale,\r\n        // bMorphed[1] - aMorphed[1]\r\n        (b[1] - a[1]) * scale\r\n    ];\r\n\r\n    const sinA = (bMorphed[1] - aMorphed[1] + (bMorphed[0] - aMorphed[0]) * sab[1] / sab[0]) *\r\n        sab[0] / (sab[0] * sab[0] - sab[1] * sab[1])\r\n\r\n    const cosA = Math.cos(Math.asin(sinA));\r\n\r\n    return other.map(([x, y]) => {\r\n        // get vector a to current point\r\n        const ac: V2 = [x - a[0], y - a[1]];\r\n\r\n        // apply same transform as for a to b\r\n        const morphedDelta = [\r\n            (cosA * scale * ac[0] - sinA * scale * ac[1]),\r\n            (sinA * scale * ac[0] + cosA * scale * ac[1])\r\n        ];\r\n\r\n        // apply morphed delta on a to get morphed c\r\n        return [\r\n            a[0] + morphedDelta[0],\r\n            a[1] + morphedDelta[1]\r\n        ];\r\n    }) as Other;\r\n}\r\n\r\nexport function fitSystemFixed<Other extends V2[]>(av: V2, aMorphed: V2, bv: V2, bMorphed: V2, other: Other): Other {\r\n    const a = av[0];\r\n    const b = av[1];\r\n\r\n    const i = bv[0];\r\n    const j = bv[1];\r\n\r\n    const g = aMorphed[0];\r\n    const h = aMorphed[1];\r\n\r\n    const k = bMorphed[0];\r\n    const l = bMorphed[1];\r\n\r\n    const d = (k - g * i / a) * a / (i * -b + j * a);\r\n    const f = (l - h * i / a) * a / (i * -b + j * a);\r\n\r\n    const c = (g - d * b) / a;\r\n    const e = (h - f * b) / a;\r\n\r\n    return other.map(([x, y]) => {\r\n        // get vector a to current point\r\n\r\n        // apply morphed delta on a to get morphed c\r\n        return [\r\n            x * c + y * d,\r\n            x * e + y * f\r\n        ];\r\n    }) as Other;\r\n}\r\n\r\nconst setLength = (v: V2, desLength = 1) => {\r\n    const length = Math.sqrt(v[0] * v[0] + v[1] * v[1]);\r\n\r\n    return [\r\n        desLength * v[0] / length,\r\n        desLength * v[1] / length\r\n    ] as V2;\r\n}\r\n\r\nconst turn90Left = (v: V2) => {\r\n    return [\r\n        v[1],\r\n        -v[0]\r\n    ] as V2;\r\n}\r\n\r\nconst turn90Right = (v: V2) => {\r\n    return [\r\n        -v[1],\r\n        v[0]\r\n    ] as V2;\r\n}\r\n\r\nconst vecFromTo = (from: V2, to: V2) => {\r\n    return [\r\n        to[0] - from[0],\r\n        to[1] - from[1]\r\n    ] as V2;\r\n}\r\n\r\nconst add = (a: V2, b: V2) => {\r\n    return [\r\n        a[0] + b[0],\r\n        a[1] + b[1]\r\n    ] as V2;\r\n}\r\n\r\nconst isSame = (a: number, b: number, delta = 1e-8) => Math.abs(a - b) < delta;\r\n\r\nconst sameDirection = (a: V2, b: V2) => {\r\n    const aUnit = setLength(a, 1);\r\n    const bUnit = setLength(b, 1);\r\n\r\n\r\n    return (isSame(aUnit[0], bUnit[0]) && isSame(aUnit[1], bUnit[1])) ||\r\n        (isSame(aUnit[0], -bUnit[0]) && isSame(aUnit[1], -bUnit[1]));\r\n}\r\n\r\nconst multiply = (v: V2, scalar: number) => {\r\n    return [\r\n        v[0] * scalar,\r\n        v[1] * scalar\r\n    ];\r\n}\r\n\r\n\r\nconst intersection = (aBase: V2, aDirection: V2, bBase: V2, bDirection: V2): 'parallel-or-identical' | V2 => {\r\n    if (sameDirection(aDirection, bDirection))\r\n        return 'parallel-or-identical';\r\n\r\n    // would result in a == 0 which in turn would result in a division by 0\r\n    // so we just switch the args, they can both have a direction in y direction of 0\r\n    // since then they would have the same direction which is already tested\r\n    if (aDirection[1] == 0) {\r\n        const tempBase = aBase;\r\n        aBase = bBase;\r\n        bBase = tempBase;\r\n\r\n        const tempDirection = aDirection;\r\n        aDirection = bDirection;\r\n        bDirection = tempDirection;\r\n    }\r\n\r\n    const a_1_x = aBase[0];\r\n    const a_1_y = aBase[1];\r\n\r\n    const a_2_x = aBase[0] + aDirection[0];\r\n    const a_2_y = aBase[1] + aDirection[1];\r\n\r\n    const a = a_1_y - a_2_y;\r\n    const b = a_2_x - a_1_x;\r\n    const c = a_1_x * a_2_y - a_2_x * a_1_y;\r\n\r\n    const b_1_x = bBase[0];\r\n    const b_1_y = bBase[1];\r\n\r\n    const b_2_x = bBase[0] + bDirection[0];\r\n    const b_2_y = bBase[1] + bDirection[1];\r\n\r\n    const d = b_1_y - b_2_y;\r\n    const e = b_2_x - b_1_x;\r\n    const f = b_1_x * b_2_y - b_2_x * b_1_y;\r\n\r\n    const y = (d * c - f * a) / (a * e - d * b);\r\n    const x = (-c - b * y) / a;\r\n\r\n    return [x, y];\r\n}\r\n\r\nexport function fitSystemNewApproach<Other extends V2[]>(p: Other, direction: 'left' | 'right', distance: number): Other {\r\n    const turner = direction == 'left' ? turn90Left : turn90Right;\r\n    const otherTurner = direction == 'left' ? turn90Right : turn90Left;\r\n\r\n    const ret: Other = [] as any;\r\n\r\n    {\r\n        const toSecond = vecFromTo(p[0], p[1]);\r\n        const unitToSecond = setLength(toSecond, distance);\r\n        const offset = turner(unitToSecond);\r\n        ret.push(add(p[0], offset));\r\n    }\r\n\r\n    for (let i = 1; i < p.length - 1; i++) {\r\n        const fromLast = vecFromTo(p[i - 1], p[i]);\r\n        const fromLastBase = add(p[i - 1], setLength(turner(fromLast), distance));\r\n\r\n        const fromNext = vecFromTo(p[i + 1], p[i]);\r\n        const fromNextBase = add(p[i + 1], setLength(otherTurner(fromNext), distance));\r\n\r\n        const hitPoint = intersection(fromLastBase, fromLast, fromNextBase, fromNext);\r\n        if (typeof hitPoint == 'string')\r\n            // TODO handle straight piece\r\n            //  should just take straight up\r\n            ret.push(add(p[i], setLength(turner(fromLast), distance)));\r\n        else\r\n            ret.push(hitPoint);\r\n        // With same length between p[i] and morphed p[i]\r\n        // ret.push(add(p[i], setLength(vecFromTo(p[i], hitPoint), distance)));\r\n    }\r\n\r\n    {\r\n        const toLast = vecFromTo(p[p.length - 2], p[p.length - 1]);\r\n        const unitToSecond = setLength(toLast, distance);\r\n        const offset = turner(unitToSecond);\r\n        ret.push(add(p[p.length - 1], offset));\r\n    }\r\n\r\n    return ret;\r\n}","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.bc = exports.factorial = void 0;\r\nexports.factorial = (function () {\r\n    const factorialCache = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000];\r\n    /**\r\n     * Calculates n!\r\n     * @param n\r\n     */\r\n    function factorial(n) {\r\n        return factorialCache[n];\r\n    }\r\n    return factorial;\r\n})();\r\nexports.bc = (function () {\r\n    const bcCache = [];\r\n    /**\r\n     * Calculates the binomial coefficient for n over k\r\n     * @param n\r\n     * @param k\r\n     */\r\n    function bc(n, k) {\r\n        if (k > n / 2)\r\n            k = n - k;\r\n        if (k == 0)\r\n            return 1;\r\n        if (k == 1)\r\n            return n;\r\n        return bcCache[n][k];\r\n    }\r\n    // building up cache\r\n    for (let n = 0; n <= 15; n++) {\r\n        bcCache[n] = [];\r\n        for (let k = 0; k <= Math.ceil(n / 2); k++) {\r\n            bcCache[n][k] = exports.factorial(n) / (exports.factorial(k) * exports.factorial(n - k));\r\n        }\r\n    }\r\n    return bc;\r\n})();\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Cache = void 0;\r\nconst DEFAULT_KEY_GENERATOR = (keys) => JSON.stringify(keys);\r\nclass Cache {\r\n    constructor(keyGenerator = DEFAULT_KEY_GENERATOR) {\r\n        this.keyGenerator = keyGenerator;\r\n        this.backing = new Map();\r\n    }\r\n    get(keys) {\r\n        return this.backing.get(this.keyGenerator(keys));\r\n    }\r\n    set(keys, value) {\r\n        return this.backing.set(this.keyGenerator(keys), value);\r\n    }\r\n}\r\nexports.Cache = Cache;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.produceGenericOffsetAt = exports.produceGenericDerived = exports.produceGenericAt = exports.assembleBezierFunction = exports.ID_POINTS = exports.ID_DISTANCE = exports.ID_ONE_MINUS_T = exports.ID_T = void 0;\r\nconst math_functions_1 = require(\"./math-functions\");\r\nconst cache_1 = require(\"./cache\");\r\nexports.ID_T = 't';\r\nexports.ID_ONE_MINUS_T = 'oneMinusT';\r\nexports.ID_DISTANCE = 'distance';\r\nexports.ID_POINTS = 'points';\r\nfunction exp(identifier, exp) {\r\n    if (exp == 0)\r\n        return '1';\r\n    let res = \"\";\r\n    const expAbs = exp < 0 ? -exp : exp;\r\n    for (let e = 0; e < expAbs; e++) {\r\n        res += identifier;\r\n        if (e < exp - 1)\r\n            res += ' * ';\r\n    }\r\n    if (exp < 0)\r\n        res = \"1 / (\" + identifier + \")\";\r\n    return res;\r\n}\r\n/**\r\n * creates a * t ^ b * (1 - t) ^ c string\r\n *\r\n * @param a\r\n * @param b\r\n * @param c\r\n * @constructor\r\n */\r\nfunction bezierMultiplier(a, b, c) {\r\n    let ret = '';\r\n    if (a != 0) {\r\n        ret += a;\r\n        if (b != 0)\r\n            ret += ' * ' + exp(exports.ID_T, b);\r\n        if (c != 0)\r\n            ret += ' * ' + exp(exports.ID_ONE_MINUS_T, c);\r\n    }\r\n    return ret.length == 0 ? '0' : ret;\r\n}\r\n/**\r\n * K derived:   a * b * t ^ (b - 1) * (1 - t) ^ c\r\n *            - a * c * t ^ b * (1 - t) ^ (c - 1)\r\n *\r\n * @param a\r\n * @param b\r\n * @param c\r\n * @constructor\r\n */\r\nfunction bezierMultiplierDerived(a, b, c) {\r\n    let ret = '';\r\n    if (a * b != 0) {\r\n        ret += (a * b);\r\n        if (b - 1 != 0)\r\n            ret += ' * ' + exp(exports.ID_T, b - 1);\r\n        if (c != 0)\r\n            ret += ' * ' + exp(exports.ID_ONE_MINUS_T, c);\r\n    }\r\n    if (a * c != 0) {\r\n        ret += (ret.length == 0 ? '' : ' ');\r\n        ret += '- ' + (a * c);\r\n        if (b != 0)\r\n            ret += ' * ' + exp(exports.ID_T, b);\r\n        if (c - 1 != 0)\r\n            ret += ' * ' + exp(exports.ID_ONE_MINUS_T, c - 1);\r\n    }\r\n    return ret.length == 0 ? '0' : ret;\r\n}\r\nfunction produceMultiplierAndComponents(grade, dimension, name, multiplierFunction) {\r\n    let res = '';\r\n    for (let g = 0; g <= grade; g++) {\r\n        res += \"const \" + \"m\" + name + g + \" = \" + multiplierFunction(math_functions_1.bc(grade, g), g, grade - g) + \";\\n\";\r\n    }\r\n    res += '\\n';\r\n    for (let d = 0; d < dimension; d++) {\r\n        res += \"const \" + \"c\" + name + d + \" = \";\r\n        for (let g = 0; g <= grade; g++) {\r\n            res += \"m\" + name + g + \" * \" + exports.ID_POINTS + \"[\" + g + \"][\" + d + \"]\";\r\n            if (g < grade) {\r\n                res += \" + \";\r\n            }\r\n            else {\r\n                res += \";\\n\";\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\nconst cache = new cache_1.Cache();\r\n/**\r\n * This function generates an general at function which is usable for this specific combination of grade and dimension.\r\n */\r\nfunction assembleBezierFunction(kFunction, grade, dimension) {\r\n    grade = grade - 1;\r\n    const cacheItem = cache.get([kFunction, grade, dimension]);\r\n    if (cacheItem)\r\n        return Object.assign({}, cacheItem);\r\n    const base = produceMultiplierAndComponents(grade, dimension, 'b' /* for base */, bezierMultiplier);\r\n    let pointSumConcat = \"\";\r\n    for (let i = 0; i < dimension; i++) {\r\n        pointSumConcat += \"    cb\" + i;\r\n        if (i < dimension - 1)\r\n            pointSumConcat += \",\\n\";\r\n        else\r\n            pointSumConcat += \"\\n\";\r\n    }\r\n    const body = \"\\\"use strict\\\";\\n\" +\r\n        \"\\n\" +\r\n        \"const \" + exports.ID_ONE_MINUS_T + \" = 1 - \" + exports.ID_T + \";\\n\" +\r\n        base + \"\\n\" +\r\n        \"return [\\n\" +\r\n        pointSumConcat + \"];\";\r\n    const func = new Function(exports.ID_POINTS, exports.ID_T, body);\r\n    cache.set([kFunction, grade, dimension], { body, func });\r\n    return { body, func };\r\n}\r\nexports.assembleBezierFunction = assembleBezierFunction;\r\nconst distantCache = new cache_1.Cache();\r\n/**\r\n * Matrix defines how the directional vector (from the first derivative) is applies to the point vector from the bezier\r\n * curve.\r\n *\r\n * For example :\r\n * ```\r\n * [\r\n *   [0, -1],\r\n *   [1, 0]\r\n * ]\r\n * ```\r\n *\r\n * Would result in the normal vector be applied in a 90° to the curve on the left side.\r\n *\r\n * @param grade\r\n * @param dimension\r\n * @param matrix\r\n */\r\nfunction assembleOffsetAtFunction(grade, dimension, matrix) {\r\n    grade = grade - 1;\r\n    const cacheItem = distantCache.get([grade, dimension, matrix]);\r\n    if (cacheItem)\r\n        return Object.assign({}, cacheItem);\r\n    const base = produceMultiplierAndComponents(grade, dimension, 'b' /* for base */, bezierMultiplier);\r\n    const derived = produceMultiplierAndComponents(grade, dimension, 'd' /* for base */, bezierMultiplierDerived);\r\n    let derivedLength = \"\";\r\n    for (let d = 0; d < dimension; d++) {\r\n        derivedLength += \"cd\" + d + \" * \" + \"cd\" + d;\r\n        if (d < dimension - 1)\r\n            derivedLength += \" + \";\r\n    }\r\n    derivedLength = \"const scale = \" + exports.ID_DISTANCE + \" / Math.sqrt(\" + derivedLength + \");\\n\";\r\n    let normalizedDelta = \"\";\r\n    for (let d = 0; d < dimension; d++)\r\n        normalizedDelta += 'const cdn' + d + ' = cd' + d + ' * scale;\\n';\r\n    let pointSumConcat = \"\";\r\n    for (let d = 0; d < dimension; d++) {\r\n        pointSumConcat += \"    cb\" + d;\r\n        const row = matrix[d];\r\n        for (let dt = 0; dt < dimension; dt++) {\r\n            const effectiveMultiplier = row[dt];\r\n            if (effectiveMultiplier == 0)\r\n                continue;\r\n            pointSumConcat += ' + ' + effectiveMultiplier + ' * cdn' + dt;\r\n        }\r\n        if (d < dimension - 1)\r\n            pointSumConcat += \",\\n\";\r\n        else\r\n            pointSumConcat += \"\\n\";\r\n    }\r\n    const body = \"\\\"use strict\\\";\\n\" +\r\n        \"\\n\" +\r\n        \"const \" + exports.ID_ONE_MINUS_T + \" = 1 - \" + exports.ID_T + \";\\n\" +\r\n        \"\\n\" +\r\n        base +\r\n        \"\\n\" +\r\n        derived +\r\n        \"\\n\" +\r\n        derivedLength +\r\n        \"\\n\" +\r\n        normalizedDelta +\r\n        \"\\n\" +\r\n        \"return [\\n\" +\r\n        pointSumConcat + \"];\";\r\n    const func = new Function(exports.ID_POINTS, exports.ID_T, exports.ID_DISTANCE, body);\r\n    distantCache.set([grade, dimension, matrix], { body, func });\r\n    return { body, func };\r\n}\r\nfunction produceGenericAt(grade, dimension) {\r\n    return assembleBezierFunction(bezierMultiplier, grade, dimension);\r\n}\r\nexports.produceGenericAt = produceGenericAt;\r\nfunction produceGenericDerived(grade, dimension) {\r\n    return assembleBezierFunction(bezierMultiplierDerived, grade, dimension);\r\n}\r\nexports.produceGenericDerived = produceGenericDerived;\r\nfunction produceGenericOffsetAt(grade, dimension, matrix) {\r\n    return assembleOffsetAtFunction(grade, dimension, matrix);\r\n}\r\nexports.produceGenericOffsetAt = produceGenericOffsetAt;\r\n","\"use strict\";\r\n/*\r\nfrom:\r\n\r\n\"use strict\";\r\nconst oneMinusT = 1 - t;\r\nconst rePoint = [NaN, NaN];\r\nconst m0 = 1 * oneMinusT * oneMinusT * oneMinusT;\r\nconst m1 = 3 * t * oneMinusT * oneMinusT;\r\nconst m2 = 3 * t * t * oneMinusT;\r\nconst m3 = 1 * t * t * t;\r\nrePoint[0] = m0 * points[0][0] + m1 * points[1][0] + m2 * points[2][0] + m3 * points[3][0];\r\nrePoint[1] = m0 * points[0][1] + m1 * points[1][1] + m2 * points[2][1] + m3 * points[3][1];\r\nreturn rePoint;\r\n\r\nto:\r\n\r\n\"use strict\";\r\nconst oneMinusT = 1 - t;\r\nconst rePoint = [NaN, NaN];\r\nconst m0 = 1 * oneMinusT * oneMinusT * oneMinusT;\r\nconst m1 = 3 * t * oneMinusT * oneMinusT;\r\nconst m2 = 3 * t * t * oneMinusT;\r\nconst m3 = 1 * t * t * t;\r\nrePoint[0] = m0 * 0 + m1 * 1 + m2 * 0 + m3 * 1;\r\nrePoint[1] = m0 * 0 + m1 * 0 + m2 * 1 + m3 * 1;\r\nreturn rePoint;\r\n*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getPlaces = void 0;\r\nconst produce_generic_1 = require(\"./produce-generic\");\r\nconst cache = new Map();\r\n// const pointsRegEx = /points\\[(\\d+)\\]\\[(\\d+)\\]/g;\r\nconst pointsRegEx = new RegExp(produce_generic_1.ID_POINTS + \"\\\\[(\\\\d+)\\\\]\\\\[(\\\\d+)\\\\]\", 'g');\r\n/**\r\n * transforms the given string into an array of strings and objects\r\n *\r\n * the string will be concatenated with the objects string representation\r\n */\r\nfunction getPlaces(str) {\r\n    // looking up cache and returning that value if it was already produced\r\n    const cacheEntry = cache.get(str);\r\n    if (cacheEntry)\r\n        return cacheEntry;\r\n    // searching for all occurrences of the pattern\r\n    const searchResults = [];\r\n    let match;\r\n    while ((match = pointsRegEx.exec(str)) != null)\r\n        searchResults.push({\r\n            length: match[0].length,\r\n            point: parseInt(match[1]),\r\n            dimension: parseInt(match[2]),\r\n            start: match.index\r\n        });\r\n    // assembling those results into the actual return value\r\n    const result = [];\r\n    let prevStop = 0;\r\n    for (const sr of searchResults) {\r\n        if (sr.start != 0) {\r\n            result[result.length] = str.slice(prevStop, sr.start);\r\n        }\r\n        prevStop = sr.start + sr.length;\r\n        result[result.length] = {\r\n            point: sr.point,\r\n            dimension: sr.dimension\r\n        };\r\n    }\r\n    // processing the last entry\r\n    const strLength = str.length;\r\n    if (prevStop != strLength)\r\n        result[result.length] = str.slice(prevStop, strLength);\r\n    // saving the result in the cache\r\n    cache.set(str, result);\r\n    return result;\r\n}\r\nexports.getPlaces = getPlaces;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.produceSpecificOffsetAtFunction = exports.produceSpecificDerivedFunction = exports.produceSpecificAtFunction = void 0;\r\nconst produce_generic_1 = require(\"./produce-generic\");\r\nconst find_points_places_1 = require(\"./find-points-places\");\r\nfunction makeSpecific(body, points) {\r\n    const places = find_points_places_1.getPlaces(body);\r\n    let newFuncBody = \"\";\r\n    for (let i = 0; i < places.length; i++) {\r\n        // every even element is a string which separates two occurrences of point[p][d]\r\n        if (i % 2 == 0) {\r\n            newFuncBody += places[i];\r\n        }\r\n        else { // every odd one is an object which has to be replaced by the numeric value in points[p][d] (the function argument)\r\n            const para = places[i];\r\n            newFuncBody += '' + points[para.point][para.dimension];\r\n        }\r\n    }\r\n    return newFuncBody;\r\n}\r\nfunction produceSpecificAtFunction(points) {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n    // the generic function is the base for the specific one\r\n    const generic = produce_generic_1.produceGenericAt(grade, dimension);\r\n    const body = generic.body;\r\n    const specificBody = makeSpecific(body, points);\r\n    return Function(produce_generic_1.ID_T, specificBody);\r\n}\r\nexports.produceSpecificAtFunction = produceSpecificAtFunction;\r\nfunction produceSpecificDerivedFunction(points) {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n    // the generic function is the base for the specific one\r\n    const generic = produce_generic_1.produceGenericDerived(grade, dimension);\r\n    const body = generic.body;\r\n    const specificBody = makeSpecific(body, points);\r\n    return Function(produce_generic_1.ID_T, specificBody);\r\n}\r\nexports.produceSpecificDerivedFunction = produceSpecificDerivedFunction;\r\nfunction produceSpecificOffsetAtFunction(points, matrix) {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n    // the generic function is the base for the specific one\r\n    const generic = produce_generic_1.produceGenericOffsetAt(grade, dimension, matrix);\r\n    const body = generic.body;\r\n    const specificBody = makeSpecific(body, points);\r\n    return Function(produce_generic_1.ID_T, produce_generic_1.ID_DISTANCE, specificBody);\r\n}\r\nexports.produceSpecificOffsetAtFunction = produceSpecificOffsetAtFunction;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Complex {\r\n    constructor(re, im) {\r\n        this.re = re || 0;\r\n        this.im = im || 0;\r\n    }\r\n}\r\n/**\r\n * Multiplies the complex numbers a and b.\r\n */\r\nComplex.multiply = function multiply(a, b) {\r\n    return new Complex(a.re * b.re - a.im * b.im, a.re * b.im + b.re * a.im);\r\n};\r\n/**\r\n * Adds Complex a to Complex b\r\n */\r\nComplex.add = function add(a, b) {\r\n    return new Complex(a.re + b.re, a.im + b.im);\r\n};\r\n/**\r\n * Divide a complex number by an real number\r\n *\r\n * n / c\r\n *\r\n * divideNCompl(3, new Complex(2, -5)) == 3 / (2 - 5i)\r\n */\r\nComplex.divideNCompl = function divideNCompl(n, c) {\r\n    const nDivByk = n / (c.re * c.re + c.im * c.im);\r\n    return new Complex(c.re * nDivByk, -c.im * nDivByk);\r\n};\r\n/**\r\n * Calculates the complex nth-roots of the given complex number.\r\n */\r\nComplex.root = function root(c, n) {\r\n    const a = c.re;\r\n    const b = c.im;\r\n    // length of the complex number \r\n    const r = Math.sqrt(a * a + b * b);\r\n    const phi = Math.acos(a / r);\r\n    const roots = new Array(n);\r\n    const nthRootOfR1 = Math.pow(r, 1 / n);\r\n    const nthRootOfR2 = (b < 0 ? -nthRootOfR1 : nthRootOfR1);\r\n    for (let k = 0; k < n; k++) {\r\n        const d = (k * 2 * Math.PI + phi) / n;\r\n        roots[k] = new Complex(nthRootOfR1 * Math.cos(d), nthRootOfR2 * Math.sin(d));\r\n    }\r\n    return roots;\r\n};\r\n/**\r\n * Is a simplified variant of the root(), which is somewhat faster and only returns the first root.\r\n */\r\nComplex.cubicRoot = function cubicRoot(c) {\r\n    const a = c.re;\r\n    const b = c.im;\r\n    // length of the complex number \r\n    const r = Math.sqrt(a * a + b * b);\r\n    const nthRootOfR1 = Math.pow(r, 1 / 3);\r\n    const nthRootOfR2 = (b < 0 ? -nthRootOfR1 : nthRootOfR1);\r\n    const d = Math.acos(a / r) / 3;\r\n    return new Complex(nthRootOfR1 * Math.cos(d), nthRootOfR2 * Math.sin(d));\r\n};\r\nexports.default = Complex;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst complex_js_1 = require(\"./complex.js\");\r\n/**\r\n * Solves 0 = a*x + b for x\r\n */\r\nfunction solveLinearEquation(a, b) {\r\n    if (a == 0)\r\n        if (b != 0)\r\n            return [];\r\n        else\r\n            return [0];\r\n    else\r\n        return [-b / a];\r\n}\r\nexports.solveLinearEquation = solveLinearEquation;\r\n/**\r\n * Solves 0 = a*x^2 + b*x + c for x\r\n */\r\nfunction solveQuadraticEquation(a, b, c) {\r\n    if (a == 0)\r\n        return solveLinearEquation(b, c);\r\n    const p = b / a;\r\n    const q = c / a;\r\n    const sqrtContent = p / 2 * p / 2 - q;\r\n    if (sqrtContent < 0) {\r\n        const sqrtR = Math.sqrt(-sqrtContent);\r\n        return [new complex_js_1.default(-p / 2, sqrtR), new complex_js_1.default(-p / 2, -sqrtR)];\r\n    }\r\n    else {\r\n        const sqrtR = Math.sqrt(sqrtContent);\r\n        return [-p / 2 + sqrtR, -p / 2 - sqrtR];\r\n    }\r\n}\r\nexports.solveQuadraticEquation = solveQuadraticEquation;\r\nconst c1Multi = new complex_js_1.default(-0.5, 0.5 * Math.sqrt(3));\r\nconst c2Multi = new complex_js_1.default(-0.5, -0.5 * Math.sqrt(3));\r\nfunction calcC(d0, d1) {\r\n    const sqrtContent = d1 * d1 - 4 * d0 * d0 * d0;\r\n    if (sqrtContent < 0) {\r\n        const imaginaryPart = Math.sqrt(-sqrtContent) / 2;\r\n        const realPart = d1 / 2;\r\n        // you could also use Complex.root to get all roots, to prevent the usage of \r\n        // multiplications for c1 and c2 in solveCubicEquation\r\n        // const [c0,c1,c2] = Complex.root(new Complex(realPart, imaginaryPart), 3);\r\n        return complex_js_1.default.cubicRoot(new complex_js_1.default(realPart, imaginaryPart));\r\n    }\r\n    else {\r\n        return new complex_js_1.default(Math.cbrt((d1 + Math.sqrt(sqrtContent)) / 2), 0);\r\n    }\r\n}\r\nfunction calcX(d0, c, a, b) {\r\n    // -1 / (3 * a) * (b + c + d / c)\r\n    const dDivc = complex_js_1.default.divideNCompl(d0, c);\r\n    const res = new complex_js_1.default(-(dDivc.re + c.re + b) / (3 * a), -(dDivc.im + c.im) / (3 * a));\r\n    return res;\r\n}\r\n/**\r\n * Solves 0 = a*x^3 + b*x^2 + c*x + d for x\r\n */\r\nfunction solveCubicEquation(a, b, c, d) {\r\n    if (a == 0)\r\n        return solveQuadraticEquation(b, c, d);\r\n    if (d == 0) {\r\n        const x = solveQuadraticEquation(a, b, c);\r\n        const y = [0];\r\n        const l = x.length;\r\n        if (l > 0) {\r\n            y[1] = x[0];\r\n            if (l > 1) {\r\n                y[2] = x[1];\r\n            }\r\n        }\r\n        return y;\r\n    }\r\n    const delta0 = b * b -\r\n        3 * a * c;\r\n    const delta1 = 2 * b * b * b -\r\n        9 * a * b * c +\r\n        27 * a * a * d;\r\n    // const delta = 18 * a * b * c * d -\r\n    //     4 * b * b * b * d +\r\n    //     b * b * c * c -\r\n    //     4 * a * c * c * c -\r\n    //     27 * a * a * d * d;\r\n    const c0 = calcC(delta0, delta1);\r\n    const c1 = complex_js_1.default.multiply(c0, c1Multi);\r\n    const c2 = complex_js_1.default.multiply(c0, c2Multi);\r\n    const x0 = calcX(delta0, c0, a, b);\r\n    const x1 = calcX(delta0, c1, a, b);\r\n    const x2 = calcX(delta0, c2, a, b);\r\n    return [x0, x1, x2];\r\n}\r\nexports.solveCubicEquation = solveCubicEquation;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createDeterministicTSearch = void 0;\r\nconst linear_quadratic_cubic_eq_solver_1 = require(\"linear-quadratic-cubic-eq-solver\");\r\n/**\r\n *\r\n * @param is the value the value is currently\r\n * @param should what value `is` should be\r\n * @param margin how far away the the value is allowed to be from the `should` result\r\n *\r\n * @returns < 0 if `is` is below the range of should - margin\r\n *          > 0 if `is` is above the range of should + margin\r\n *          = 0 if `is` is withing in the range\r\n */\r\nconst inRange = (is, should, margin) => {\r\n    const spm = should + margin;\r\n    if (is > spm)\r\n        return is - spm;\r\n    const smm = should - margin;\r\n    if (is < smm)\r\n        return is - smm;\r\n    return 0;\r\n};\r\n/**\r\n * Removes complex numbers and converts complex numbers with an imaginary part of smaller than 1e-8 to a real number.\r\n * @param n\r\n */\r\nconst cleanSolutions = (n) => {\r\n    const k = [];\r\n    for (const h of n) {\r\n        if (typeof h == 'number')\r\n            k.push(h);\r\n        else if (inRange(h.im, 0, 1e-8) == 0)\r\n            k.push(h.re);\r\n    }\r\n    return k;\r\n};\r\nconst solvingFunctions = [\r\n    (p, f) => {\r\n        const a = p[1] - p[0];\r\n        const b = p[0] - f;\r\n        return cleanSolutions(linear_quadratic_cubic_eq_solver_1.solveLinearEquation(a, b));\r\n    },\r\n    (p, f) => {\r\n        const a = p[0] - 2 * p[1] + p[2];\r\n        const b = -2 * p[0] + 2 * p[1];\r\n        const c = p[0] - f;\r\n        return cleanSolutions(linear_quadratic_cubic_eq_solver_1.solveQuadraticEquation(a, b, c));\r\n    },\r\n    (p, f) => {\r\n        const a = -p[0] + 3 * p[1] - 3 * p[2] + p[3];\r\n        const b = 3 * p[0] - 6 * p[1] + 3 * p[2];\r\n        const c = -3 * p[0] + 3 * p[1];\r\n        const d = p[0] - f;\r\n        return cleanSolutions(linear_quadratic_cubic_eq_solver_1.solveCubicEquation(a, b, c, d));\r\n    }\r\n];\r\nfunction createDeterministicTSearch(points) {\r\n    const grade = points.length;\r\n    const dimension = points[0].length;\r\n    if (grade == null || grade < 2 || grade > 4)\r\n        return null;\r\n    const dimensionalSplit = [];\r\n    for (let d = 0; d < dimension; d++) {\r\n        const ds = [];\r\n        for (let p = 0; p < points.length; p++)\r\n            ds.push(points[p][d]);\r\n        dimensionalSplit.push(ds);\r\n    }\r\n    const func = solvingFunctions[grade - 2];\r\n    return (v, d) => {\r\n        return func(dimensionalSplit[d], v);\r\n    };\r\n}\r\nexports.createDeterministicTSearch = createDeterministicTSearch;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StaticBezier = void 0;\r\nconst produce_specific_1 = require(\"./produce-specific\");\r\nconst deterministic_t_search_1 = require(\"./deterministic-t-search\");\r\nconst createSpecificAtFunction = (points) => {\r\n    const at = produce_specific_1.produceSpecificAtFunction(points);\r\n    if (at == null)\r\n        throw new Error(\"could not create specific function for points \" + JSON.stringify(points));\r\n    return at;\r\n};\r\nconst createDeterministicTSearchFunction = (points) => {\r\n    const tSearch = deterministic_t_search_1.createDeterministicTSearch(points);\r\n    if (tSearch == null)\r\n        throw new Error(\"could not create deterministic function for points \" + JSON.stringify(points));\r\n    return tSearch;\r\n};\r\nconst createSpecificDerivedFunction = (points) => {\r\n    const derived = produce_specific_1.produceSpecificDerivedFunction(points);\r\n    if (derived == null)\r\n        throw new Error(\"could not create derived function for points \" + JSON.stringify(points));\r\n    return derived;\r\n};\r\nconst leftMatrix = [\r\n    [0, -1],\r\n    [1, 0]\r\n];\r\nconst rightMatrix = [\r\n    [0, 1],\r\n    [-1, 0]\r\n];\r\nconst createSpecificOffsetAtFunction = (points, matrix) => {\r\n    const offset = produce_specific_1.produceSpecificOffsetAtFunction(points, matrix);\r\n    if (offset == null)\r\n        throw new Error(\"could not create offset function for points \" + JSON.stringify(points));\r\n    return offset;\r\n};\r\nclass StaticBezier {\r\n    constructor(points) {\r\n        this.points = points;\r\n    }\r\n    at(t) {\r\n        this.at = createSpecificAtFunction(this.points);\r\n        return this.at(t);\r\n    }\r\n    direction(t) {\r\n        this.direction = createSpecificDerivedFunction(this.points);\r\n        return this.direction(t);\r\n    }\r\n    tSearch(value, dimension) {\r\n        if (this.points.length > 4)\r\n            this.tSearch = () => {\r\n                throw new Error('can not t search with a grade greater than 4');\r\n            };\r\n        else\r\n            this.tSearch = createDeterministicTSearchFunction(this.points);\r\n        return this.tSearch(value, dimension);\r\n    }\r\n    offsetPointLeft(t, distance) {\r\n        if (this.points[0].length == 2) {\r\n            this.offsetPointLeft = createSpecificOffsetAtFunction(this.points, leftMatrix);\r\n        }\r\n        else {\r\n            this.offsetPointLeft = () => {\r\n                throw new Error('can not get the offset point in a ' + this.points[0].length + '-dimensional Bezier,' +\r\n                    ' only 2-dimensional are permitted');\r\n            };\r\n        }\r\n        return this.offsetPointLeft(t, distance);\r\n    }\r\n    offsetPointRight(t, distance) {\r\n        if (this.points[0].length == 2) {\r\n            this.offsetPointRight = createSpecificOffsetAtFunction(this.points, rightMatrix);\r\n        }\r\n        else {\r\n            this.offsetPointRight = () => {\r\n                throw new Error('can not get the offset point in a ' + this.points[0].length + '-dimensional Bezier,' +\r\n                    ' only 2-dimensional are permitted');\r\n            };\r\n        }\r\n        return this.offsetPointRight(t, distance);\r\n    }\r\n}\r\nexports.StaticBezier = StaticBezier;\r\n","import {EventEmitter} from \"event-emitter-typesafe\";\r\nimport {fitSystemNewApproach, V2} from \"./fit-system\";\r\nimport {StaticBezier} from \"nd-bezier\";\r\n\r\nconst height = 900;\r\nconst width = 1400;\r\nconst margin = 100;\r\n\r\ntype Vector2 = [number, number];\r\n\r\n/*\r\nK(t) = a * t ^ b * (1 - t) ^ c\r\nK'(t) = a * b * t ^ (b - 1) * (1 - t) ^ c - a * c * t ^ b * (1 - t) ^ (c - 1)\r\n*/\r\n\r\n//\r\n// let bezierPoints: Vector2[] = [];\r\n//\r\nfunction ascent(points: Vector2[], t: number) {\r\n    \"use strict\";\r\n\r\n    const oneMinusT = 1 - t;\r\n    const m0 = -3 * oneMinusT * oneMinusT;\r\n    const m1 = 9 * t * t - 12 * t + 3;\r\n    const m2 = 6 * t - 9 * t * t;\r\n    const m3 = 3 * t * t;\r\n    return [\r\n        m0 * points[0][0] + m1 * points[1][0] + m2 * points[2][0] + m3 * points[3][0],\r\n        m0 * points[0][1] + m1 * points[1][1] + m2 * points[2][1] + m3 * points[3][1]\r\n    ];\r\n}\r\n\r\nconst pointRadius = 20;\r\n\r\nfunction drawPoints(ctx: CanvasRenderingContext2D, points: Vector2[], radius = pointRadius) {\r\n    ctx.beginPath();\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n        const p = points[i];\r\n        ctx.moveTo(p[0], p[1]);\r\n        ctx.arc(p[0], p[1], radius, 0, 360);\r\n    }\r\n\r\n    ctx.fill();\r\n    ctx.closePath();\r\n}\r\n\r\nfunction drawPolyline(ctx: CanvasRenderingContext2D, points: Vector2[]) {\r\n    if (points.length == 0)\r\n        return;\r\n\r\n    ctx.beginPath();\r\n\r\n    const startPoint = points[0];\r\n    ctx.moveTo(startPoint[0], startPoint[1]);\r\n    for (let i = 1; i < points.length; i++) {\r\n        const point = points[i];\r\n        ctx.lineTo(point[0], point[1]);\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n}\r\n\r\n/*\r\nfunction getPointsLeftAndRightFromBezier(points: Vector2[], t: number, distance: number): [V2, V2, V2] {\r\n    const asc = ascent(points, t);\r\n    const ascLength = Math.sqrt(asc[0] * asc[0] + asc[1] * asc[1]);\r\n    const ascNorm = [distance * asc[0] / ascLength, distance * asc[1] / ascLength];\r\n\r\n    let bezier = new StaticBezier(points);\r\n    const point = bezier.at(t);\r\n\r\n    return [\r\n        // left point\r\n        [point[0] + ascNorm[1], point[1] + -ascNorm[0]],\r\n\r\n        // center point\r\n        [point[0], point[1]],\r\n\r\n        // right point\r\n        [point[0] + -ascNorm[1], point[1] + ascNorm[0]]\r\n    ];\r\n}\r\n*/\r\n\r\nfunction getPointsLeftAndRightFromBezier(points: Vector2[], t: number, distance: number): [V2, V2, V2] {\r\n    const staticBezier = new StaticBezier(points);\r\n\r\n    const leftPoint = staticBezier.offsetPointLeft(t, distance) as V2;\r\n    const rightPoint = staticBezier.offsetPointRight(t, distance) as V2;\r\n\r\n    return [\r\n        // left point\r\n        leftPoint,\r\n\r\n        // center point\r\n        staticBezier.at(t) as V2,\r\n\r\n        // right point\r\n        rightPoint\r\n    ];\r\n}\r\n\r\nfunction drawOffsetBezier(ctx: CanvasRenderingContext2D, pinPoints: V2[], spikes: number, distance: number, renderSpikes: boolean) {\r\n    if (spikes == 0 || pinPoints.length < 2)\r\n        return;\r\n\r\n    const rightSideLines: [Vector2, Vector2][] = [];\r\n    const leftSideLines: [Vector2, Vector2][] = [];\r\n\r\n    for (let i = 0; i <= spikes; i++) {\r\n        const t = i / spikes;\r\n        const [left, center, right] = getPointsLeftAndRightFromBezier(pinPoints, t, distance);\r\n\r\n        rightSideLines.push([\r\n            center,\r\n            right\r\n        ]);\r\n\r\n        leftSideLines.push([\r\n            center,\r\n            left\r\n        ]);\r\n    }\r\n\r\n    const originalStrokeStyle = ctx.strokeStyle;\r\n\r\n    ctx.strokeStyle = '#444';\r\n    drawPolyline(ctx, rightSideLines.map(p => p[1]));\r\n\r\n    // ctx.strokeStyle = '#f00';\r\n    // drawPolyline(ctx, rightSideLines.map(p => [\r\n    //     (p[0][0] + p[1][0]) / 2,\r\n    //     (p[0][1] + p[1][1]) / 2\r\n    // ]));\r\n\r\n\r\n    ctx.strokeStyle = '#444';\r\n    drawPolyline(ctx, leftSideLines.map(p => p[1]));\r\n\r\n    // ctx.strokeStyle = '#f00';\r\n    // drawPolyline(ctx, leftSideLines.map(p => [\r\n    //     (p[0][0] + p[1][0]) / 2,\r\n    //     (p[0][1] + p[1][1]) / 2\r\n    // ]));\r\n\r\n\r\n    if (renderSpikes) {\r\n        const originalWidth = ctx.lineWidth;\r\n        ctx.strokeStyle = '#0ff';\r\n        ctx.lineWidth = originalWidth / 2;\r\n        ctx.beginPath();\r\n        for (const arr of [leftSideLines, rightSideLines]) {\r\n            for (const [start, end] of arr) {\r\n                ctx.moveTo(start[0], start[1]);\r\n                ctx.lineTo(end[0], end[1]);\r\n            }\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        ctx.lineWidth = originalWidth;\r\n    }\r\n\r\n    ctx.strokeStyle = originalStrokeStyle;\r\n}\r\n\r\nfunction drawBezier(pinPoints: Vector2[], ctx: CanvasRenderingContext2D, lines: number, spikes = lines) {\r\n    if (pinPoints.length < 2)\r\n        return;\r\n\r\n    const bezier = new StaticBezier(pinPoints);\r\n    const points: Vector2[] = [];\r\n\r\n    for (let i = 0; i <= lines; i++) {\r\n        points.push(bezier.at(i / lines) as Vector2);\r\n    }\r\n\r\n    drawPolyline(ctx, points);\r\n}\r\n\r\nconst options = {\r\n    approachDistance: [\"1. Approach: Normal-Vector\", true],\r\n    approachControlPoints: [\"2. Approach: Shift control points\", false],\r\n    spikes: [\"Spikes for offset Beziér\", false],\r\n    attachedCoords: [\"Write coordinates attached to node\", false],\r\n}\r\n\r\nfunction getOption(key: keyof typeof options) {\r\n    return options[key][1] as boolean;\r\n}\r\n\r\nconst frm = new Intl.NumberFormat('en-US', {\r\n    minimumFractionDigits: 2,\r\n    maximumFractionDigits: 2,\r\n    useGrouping: false\r\n}).format;\r\n\r\nconst nrFrm = (nr: number) => frm(nr).padStart(7, ' ');\r\nconst arrFrm = (arr: number[]) => '[' + arr.map(nrFrm).join(', ') + ']';\r\n\r\nlet debugElem!: HTMLOutputElement;\r\nlet context!: CanvasRenderingContext2D;\r\n\r\ntype FillStyle = CanvasRenderingContext2D[\"fillStyle\"];\r\n\r\nexport function debug(point: V2, name: string, dotColor: FillStyle = 'black', textColor: FillStyle = 'black', radius: number = pointRadius) {\r\n    if (!debugElem || !context)\r\n        return;\r\n\r\n    const frmPos = arrFrm(point);\r\n    debugElem.innerText += name + ': ' + frmPos + '\\n';\r\n\r\n    const originalFill = context.fillStyle;\r\n\r\n    context.fillStyle = dotColor;\r\n    drawPoints(context, [point]);\r\n\r\n    context.fillStyle = textColor;\r\n    context.textAlign = 'left';\r\n    context.textBaseline = 'bottom';\r\n    const str = getOption(\"attachedCoords\") ? name + ' ' + frmPos : name;\r\n    context.fillText(str, point[0] + radius, point[1] - radius);\r\n\r\n    context.fillStyle = originalFill;\r\n}\r\n\r\n\r\nfunction initialize() {\r\n    const debugOutput = document.getElementById('debug-output') as HTMLOutputElement;\r\n    const canvas = document.getElementById('canvas') as HTMLCanvasElement;\r\n    const optionContainer = document.getElementById('control') as HTMLDivElement;\r\n\r\n    debugElem = debugOutput;\r\n\r\n    canvas.setAttribute('height', height + '');\r\n    canvas.setAttribute('width', width + '');\r\n\r\n\r\n    for (const key of Object.keys(options)) {\r\n        const [description, defaultValue] = (options as any)[key];\r\n        const checkbox = document.createElement('input');\r\n        const id = \"option-\" + key;\r\n        checkbox.id = id;\r\n        checkbox.type = \"checkbox\";\r\n        checkbox.checked = defaultValue;\r\n\r\n        const label = document.createElement('label');\r\n        label.innerText = description;\r\n        label.htmlFor = id;\r\n\r\n        const wrapper = document.createElement('div');\r\n        wrapper.className = \"option-wrapper\";\r\n\r\n        wrapper.append(checkbox, label);\r\n\r\n        optionContainer.append(wrapper);\r\n\r\n        checkbox.addEventListener('change', () => (options as any)[key][1] = checkbox.checked);\r\n    }\r\n\r\n    const getCanvasPosition = (() => {\r\n        let cache: undefined | ClientRect = undefined;\r\n\r\n        const invalidate = () => {\r\n            requestAnimationFrame(invalidate);\r\n            cache = undefined;\r\n        }\r\n        invalidate();\r\n\r\n        return function getCanvasPosition() {\r\n            if (cache)\r\n                return cache;\r\n\r\n            return cache = canvas.getBoundingClientRect()\r\n        }\r\n    })();\r\n\r\n    function mapPosition(ev: MouseEvent) {\r\n        const rect = getCanvasPosition();\r\n\r\n        return [\r\n            ev.clientX - rect.left,\r\n            ev.clientY - rect.top\r\n        ] as Vector2;\r\n    }\r\n\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    if (!ctx)\r\n        throw new Error('Could not initialize');\r\n\r\n    context = ctx;\r\n\r\n    ctx.lineWidth = 4;\r\n    ctx.strokeStyle = \"#000\";\r\n\r\n    const awaitFrame = () => new Promise(res => requestAnimationFrame(res));\r\n\r\n\r\n    interface MouseEvents {\r\n        \"click\": { type: \"click\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"dragstart\": { type: \"dragstart\", original: MouseEvent, position: Vector2 };\r\n        \"drag\": { type: \"drag\", original: MouseEvent, position: Vector2, previous: Vector2 };\r\n        \"dragend\": { type: \"dragend\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"mousedown\": { type: \"mousedown\", original: MouseEvent, position: Vector2 };\r\n        \"mouseup\": { type: \"mouseup\", original: MouseEvent, position: Vector2 };\r\n\r\n        \"mousemove\": { type: \"mousemove\", original: MouseEvent, position: Vector2 };\r\n    }\r\n\r\n    const mouseEvents = new EventEmitter<MouseEvents>();\r\n\r\n    document.addEventListener(\"mousemove\", ev =>\r\n        mouseEvents.emit(\"mousemove\", {type: \"mousemove\", original: ev, position: mapPosition(ev)}));\r\n\r\n    document.addEventListener(\"mousedown\", ev =>\r\n        mouseEvents.emit(\"mousedown\", {type: \"mousedown\", original: ev, position: mapPosition(ev)}));\r\n\r\n    document.addEventListener(\"mouseup\", ev =>\r\n        mouseEvents.emit(\"mouseup\", {type: \"mouseup\", original: ev, position: mapPosition(ev)}));\r\n\r\n    let lastMouseDownPos: Vector2 | undefined = undefined;\r\n    let emittedDragStart = false;\r\n\r\n    mouseEvents.addEventListener(\"mousedown\", ev => {\r\n        lastMouseDownPos = ev.position;\r\n        emittedDragStart = false;\r\n    });\r\n\r\n    mouseEvents.addEventListener(\"mouseup\", ev => {\r\n        lastMouseDownPos = undefined;\r\n        if (emittedDragStart)\r\n            mouseEvents.emit(\"dragend\", {\r\n                type: \"dragend\",\r\n                original: ev.original,\r\n                position: ev.position\r\n            })\r\n        else\r\n            mouseEvents.emit(\"click\", {\r\n                type: \"click\",\r\n                original: ev.original,\r\n                position: ev.position\r\n            })\r\n    });\r\n\r\n    let mousePosition: V2 | undefined = undefined;\r\n\r\n    mouseEvents.addEventListener(\"mousemove\", ev => {\r\n        mousePosition = ev.position;\r\n        if (ev.original.buttons > 0 && lastMouseDownPos) {\r\n            const lmdp = lastMouseDownPos;\r\n            lastMouseDownPos = ev.position;\r\n\r\n            if (!emittedDragStart) {\r\n                emittedDragStart = true;\r\n                mouseEvents.emit(\"dragstart\", {\r\n                    type: \"dragstart\",\r\n                    original: ev.original,\r\n                    position: ev.position\r\n                });\r\n            } else {\r\n                mouseEvents.emit(\"drag\", {\r\n                    type: \"drag\",\r\n                    original: ev.original,\r\n                    position: ev.position,\r\n                    previous: lmdp\r\n                })\r\n            }\r\n        }\r\n    })\r\n\r\n    type Values<T> = T extends object ? T extends { [key in keyof T]: infer V } ? V : never : never;\r\n\r\n    let occurredEvents = [] as Values<MouseEvents>[];\r\n\r\n    mouseEvents.addEventListener(\"click\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"dragstart\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"drag\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"dragend\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mousedown\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mouseup\", ev => occurredEvents.push(ev));\r\n    mouseEvents.addEventListener(\"mousemove\", ev => occurredEvents.push(ev));\r\n\r\n    const distance = 100;\r\n    const bezierWidth = 800 + distance;\r\n    const bezierHeight = 500 + distance * 2;\r\n\r\n    const top = (height - bezierHeight) / 2;\r\n    const left = (width - bezierWidth) / 2;\r\n    const bottom = height - top;\r\n    const right = width - left;\r\n\r\n    let setPoints = [\r\n        [left + distance / 2, top + distance],\r\n        [right - distance / 2, top + distance],\r\n        [right - distance / 2, bottom - distance],\r\n        [left + distance / 2, bottom - distance]\r\n    ] as Vector2[];\r\n\r\n    function getHitPoint(points: Vector2[], pos: Vector2, range: number): number | undefined {\r\n\r\n        for (let i = 0; i < points.length; i++) {\r\n            const point = points[i];\r\n            const deltaX = point[0] - pos[0];\r\n            const deltaY = point[1] - pos[1];\r\n\r\n            if ((deltaX * deltaX + deltaY * deltaY) <= range * range)\r\n                return i;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    let draggedNodeIndex: undefined | number;\r\n\r\n    function indexToLetter(nr: number) {\r\n        return String.fromCharCode('a'.charCodeAt(0) + nr);\r\n    }\r\n\r\n    ctx.font = `15px Verdana`;\r\n\r\n    const start = Date.now();\r\n    (async () => {\r\n        while (true) {\r\n            const delta = Date.now() - start;\r\n\r\n            const perc = (Math.sin(delta / 10000 * Math.PI) + 1) / 2;\r\n            ctx.clearRect(0, 0, width, height);\r\n            debugElem.innerText = '';\r\n\r\n            interface CombinedDragCommand {\r\n                start: boolean;\r\n                progressed: boolean;\r\n                ended: boolean;\r\n\r\n                startPosition: Vector2;\r\n                endPosition: Vector2;\r\n            }\r\n\r\n            const combinedDragCommands: CombinedDragCommand[] = [];\r\n            let currentDrag: CombinedDragCommand | undefined = undefined;\r\n\r\n            for (const event of occurredEvents) {\r\n                if (event.type == \"dragstart\") {\r\n                    currentDrag = {\r\n                        start: true,\r\n                        progressed: false,\r\n                        ended: false,\r\n\r\n                        startPosition: event.position,\r\n                        endPosition: event.position\r\n                    };\r\n                } else if (event.type == \"drag\") {\r\n                    if (currentDrag) {\r\n                        currentDrag.progressed = true;\r\n                        currentDrag.endPosition = event.position;\r\n                    } else {\r\n                        // when the drag started before this frame\r\n                        currentDrag = {\r\n                            start: false,\r\n                            progressed: true,\r\n                            ended: false,\r\n\r\n                            startPosition: event.previous,\r\n                            endPosition: event.position\r\n                        };\r\n                    }\r\n                } else if (event.type == \"dragend\") {\r\n                    if (currentDrag) {\r\n                        currentDrag.ended = true;\r\n                        currentDrag.endPosition = event.position;\r\n                        combinedDragCommands.push(currentDrag);\r\n                        currentDrag = undefined;\r\n                    } else {\r\n                        // if the drag ends without any movement in this frame\r\n                        combinedDragCommands.push({\r\n                            start: false,\r\n                            progressed: false,\r\n                            ended: true,\r\n\r\n                            startPosition: event.position,\r\n                            endPosition: event.position\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentDrag)\r\n                combinedDragCommands.push(currentDrag);\r\n\r\n            for (const dragCommand of combinedDragCommands) {\r\n                if (draggedNodeIndex == undefined)\r\n                    draggedNodeIndex = getHitPoint(setPoints, dragCommand.startPosition, pointRadius);\r\n\r\n                if (draggedNodeIndex != undefined) {\r\n                    const deltaX = dragCommand.endPosition[0] - dragCommand.startPosition[0];\r\n                    const deltaY = dragCommand.endPosition[1] - dragCommand.startPosition[1];\r\n\r\n                    const point = setPoints[draggedNodeIndex];\r\n\r\n                    // console.log('hotted point', hotPoint, point);\r\n                    point[0] += deltaX;\r\n                    point[1] += deltaY;\r\n\r\n                    if (dragCommand.ended)\r\n                        draggedNodeIndex = undefined;\r\n                }\r\n            }\r\n\r\n            if (draggedNodeIndex != undefined) {\r\n                canvas.style.cursor = 'grabbing';\r\n            } else if (mousePosition) {\r\n                if (getHitPoint(setPoints, mousePosition, pointRadius) != undefined)\r\n                    canvas.style.cursor = 'grab';\r\n                else\r\n                    canvas.style.cursor = 'default';\r\n            }\r\n\r\n            for (const event of occurredEvents) {\r\n                const [x, y] = event.position;\r\n                if (event.type == \"click\" && x >= 0 && x <= width && y >= 0 && y <= height) {\r\n                    const elem = getHitPoint(setPoints, event.position, pointRadius);\r\n                    if (elem != undefined) {\r\n                        setPoints.splice(elem, 1);\r\n                    } else {\r\n                        setPoints.push(event.position);\r\n                    }\r\n                }\r\n            }\r\n\r\n            occurredEvents = [];\r\n\r\n            const numberOfLines = 40;\r\n\r\n            if (setPoints.length > 1) {\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.lineWidth = 4;\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n                drawBezier(setPoints, ctx, numberOfLines);\r\n\r\n                if (getOption(\"approachDistance\"))\r\n                    drawOffsetBezier(ctx, setPoints, numberOfLines, distance, getOption(\"spikes\"));\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n                if (getOption(\"approachControlPoints\")) {\r\n                    for (const side of ['left', 'right']) {\r\n                        const morphed = fitSystemNewApproach(setPoints, side as any, distance);\r\n                        ctx.lineWidth = 4;\r\n                        ctx.strokeStyle = \"#f0a\";\r\n\r\n                        drawBezier(morphed, ctx, numberOfLines, 0);\r\n                        ctx.setLineDash([8, 8]);\r\n                        drawPolyline(ctx, morphed);\r\n                        ctx.setLineDash([]);\r\n\r\n                        for (let i = 0; i < morphed.length; i++)\r\n                            debug(morphed[i], indexToLetter(i) + '_morphed_' + side);\r\n                    }\r\n                }\r\n\r\n                ctx.fillStyle = 'black';\r\n                ctx.strokeStyle = \"#000\";\r\n\r\n\r\n            }\r\n\r\n            drawPolyline(ctx, setPoints);\r\n\r\n            for (let i = 0; i < setPoints.length; i++)\r\n                debug(setPoints[i], indexToLetter(i), draggedNodeIndex == i ? 'red' : 'orange');\r\n\r\n            await awaitFrame();\r\n        }\r\n    })()\r\n\r\n\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', initialize);"]}